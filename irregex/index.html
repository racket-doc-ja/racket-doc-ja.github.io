<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Mirrored from docs.racket-lang.org/irregex/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 07 Sep 2022 03:01:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>IrRegular Expressions</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="#" class="tocviewselflink" data-pltdoc="x">Ir<span class="mywbr"> &nbsp;</span>Regular Expressions</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._top%29" class="tocsubseclink" data-pltdoc="x">Ir<span class="mywbr"> &nbsp;</span>Regular Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.6</span></div><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.6&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h2 x-source-module="(lib &quot;irregex/irregex.scrbl&quot;)" x-source-pkg="irregex" x-part-tag="&quot;top&quot;"><a name="(part._top)"></a><a name="(part._.Ir.Regular_.Expressions)"></a><a name="(mod-path._irregex)"></a>IrRegular Expressions</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Alex Shinn</p></span></div><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#" class="RktModLink" data-pltdoc="x"><span class="RktSym">irregex</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/irregex" title="Install this package using `raco pkg install irregex`"><span class="stt">irregex</span></a></span></td></tr></table></div><div class="SIntrapara">This package contains Alex Shinn&rsquo;s "IrRegex". It&rsquo;s
a regular expression matcher, including both a traditional
character-based syntax and also an implementation of
Olin Shivers&rsquo; SRE parenthesized syntax.</div><div class="SIntrapara">The code was written for standard Scheme, more specifically
R[4567]RS code.</div><div class="SIntrapara">I (John Clements) have performed a hasty port of this code to
Racket. The required changes were extremely minimal, so
it should be possible to stay up-to-date with upstream
changes.</div><div class="SIntrapara">What follows is the verbatim text of "irregex.doc",
part of the original package.</div></p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\title{IrRegular Expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://synthcode.com/]{Alex Shinn}</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://synthcode.com/scheme/irregex/irregex-0.9.9.tar.gz]{Download Version 0.9.9}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\centered{\italic{\pre{</span></p></td></tr><tr><td><p><span class="stt">At this moment there was a loud ring at the bell, and I could</span></p></td></tr><tr><td><p><span class="stt">hear Mrs. Hudson, our landlady, raising her voice in a wail of</span></p></td></tr><tr><td><p><span class="stt">expostulation and dismay.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">"By heaven, Holmes," I said, half rising, "I believe that</span></p></td></tr><tr><td><p><span class="stt">they are really after us."</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">"No, it's not quite so bad as that.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">It is the unofficial</span></p></td></tr><tr><td><p><span class="stt">force, -- the Baker Street irregulars."}}}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">A fully portable and efficient R[4567]RS implementation of regular</span></p></td></tr><tr><td><p><span class="stt">expressions, supporting both POSIX syntax with various (irregular)</span></p></td></tr><tr><td><p><span class="stt">PCRE extensions, as well as SCSH's SRE syntax, with various aliases</span></p></td></tr><tr><td><p><span class="stt">for commonly used patterns.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">DFA matching is used when possible,</span></p></td></tr><tr><td><p><span class="stt">otherwise a closure-compiled NFA approach is used.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The library makes</span></p></td></tr><tr><td><p><span class="stt">no assumptions about the encoding of strings or range of characters</span></p></td></tr><tr><td><p><span class="stt">and can thus be used in Unicode-aware Scheme implementations.</span></p></td></tr><tr><td><p><span class="stt">Matching may be performed over standard Scheme strings, or over</span></p></td></tr><tr><td><p><span class="stt">arbitrarily chunked streams of strings.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\section{Installation}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Just</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\scheme{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(load "irregex.scm")</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">in your favorite Scheme implementation and you're good to go!</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There is a global variable \scheme{*all-chars*} which is used for</span></p></td></tr><tr><td><p><span class="stt">generating character set complements.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">This defaults to the full</span></p></td></tr><tr><td><p><span class="stt">Unicode range 0..#x10FFFF, but if your implementation can't handle</span></p></td></tr><tr><td><p><span class="stt">characters that large you'll need to adjust it (a suitable ASCII</span></p></td></tr><tr><td><p><span class="stt">definition is commented out in the source).</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">If using an R7RS Schem you can use irregex.sld, or install</span></p></td></tr><tr><td><p><span class="stt">\scheme{(chibi irregex)} from \url{http://snow-fort.org/}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">If you are using an R6RS Scheme, you can instead</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\scheme{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(load "irregex-r6rs.scm")</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There are also a handful of utility procedures described below you may</span></p></td></tr><tr><td><p><span class="stt">wish to use in irregex-utils.scm.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">If you are using Chicken Scheme IrRegex is built in as a core unit, so</span></p></td></tr><tr><td><p><span class="stt">no need to install it.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">To use it, you just need to \scheme{(use irregex)}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\section{Specification}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsection{Procedures}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex &lt;posix-string-or-sre&gt; [&lt;options&gt; ...])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(string-&gt;irregex &lt;posix-string&gt; [&lt;options&gt; ...])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(sre-&gt;irregex &lt;sre&gt; [&lt;options&gt; ...])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Compiles a regular expression from either a POSIX-style regular</span></p></td></tr><tr><td><p><span class="stt">expression string (with most PCRE extensions) or an SCSH-style SRE.</span></p></td></tr><tr><td><p><span class="stt">There is no \scheme{(rx ...)} syntax - just use normal Scheme lists, with</span></p></td></tr><tr><td><p><span class="stt">\scheme{quasiquote} if you like.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Technically a string by itself could be considered a valid (though</span></p></td></tr><tr><td><p><span class="stt">rather silly) SRE, so if you want to just match a literal string you</span></p></td></tr><tr><td><p><span class="stt">should use something like \scheme{(irregex `(: ,str))}, or use the explicit</span></p></td></tr><tr><td><p><span class="stt">\scheme{(sre-&gt;irregex str)}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The options are a list of any of the following symbols:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'i}, \scheme{'case-insensitive} - match case-insensitively</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'m}, \scheme{'multi-line}</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- treat string as multiple lines (effects ^ and $)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'s}, \scheme{'single-line}</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- treat string as a single line (. can match newline)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'utf8}</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- utf8-mode (assumes strings are byte-strings)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'fast}</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- try to optimize the regular expression</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'small}</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- try to compile a smaller regular expression</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{'backtrack}</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">- enforce a backtracking implementation</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The \scheme{'fast} and \scheme{'small} options are heuristic guidelines and will</span></p></td></tr><tr><td><p><span class="stt">not necessarily make the compiled expression faster or smaller.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(string-&gt;sre &lt;str&gt;)}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(maybe-string-&gt;sre &lt;obj&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">For backwards compatibility, procedures to convert a POSIX string into</span></p></td></tr><tr><td><p><span class="stt">an SRE.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\scheme{maybe-string-&gt;sre} does the same thing, but only if the argument is</span></p></td></tr><tr><td><p><span class="stt">a string, otherwise it assumes \scheme{&lt;obj&gt;} is an SRE and returns it</span></p></td></tr><tr><td><p><span class="stt">as-is.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">This is useful when you want to provide an API that allows</span></p></td></tr><tr><td><p><span class="stt">either a POSIX string or SRE (like \scheme{irregex} or \scheme{irregex-search}</span></p></td></tr><tr><td><p><span class="stt">below) - it ensures the result is an SRE.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex? &lt;obj&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns \scheme{#t} iff the object is a regular expression.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-search &lt;irx&gt; &lt;str&gt; [&lt;start&gt; &lt;end&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Searches for any instances of the pattern &lt;irx&gt; (a POSIX string, SRE</span></p></td></tr><tr><td><p><span class="stt">sexp, or pre-compiled regular expression) in &lt;str&gt;, optionally between</span></p></td></tr><tr><td><p><span class="stt">the given range.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If a match is found, returns a match object,</span></p></td></tr><tr><td><p><span class="stt">otherwise returns \scheme{#f}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Match objects can be used to query the original range of the string or</span></p></td></tr><tr><td><p><span class="stt">its submatches using the \scheme{irregex-match-*} procedures below.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Examples:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search "foobar" "abcFOOBARdef") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search (irregex "foobar" 'i) "abcFOOBARdef") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(w/nocase "foobar") "abcFOOBARdef") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Note, the actual match result is represented by a vector in the</span></p></td></tr><tr><td><p><span class="stt">default implementation.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Throughout this document, we'll just write</span></p></td></tr><tr><td><p><span class="stt">\scheme{&lt;match&gt;} to show that a successful match was returned when the</span></p></td></tr><tr><td><p><span class="stt">details are not important.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Matching follows the POSIX leftmost, longest semantics, when</span></p></td></tr><tr><td><p><span class="stt">searching.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">That is, of all possible matches in the string,</span></p></td></tr><tr><td><p><span class="stt">\scheme{irregex-search} will return the match at the first position</span></p></td></tr><tr><td><p><span class="stt">(leftmost).</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If multiple matches are possible from that same first</span></p></td></tr><tr><td><p><span class="stt">position, the longest match is returned.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match &lt;irx&gt; &lt;str&gt; [&lt;start&gt; &lt;end&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Like \scheme{irregex-search}, but performs an anchored match against the</span></p></td></tr><tr><td><p><span class="stt">beginning and end of the substring specified by &lt;start&gt; and &lt;end&gt;,</span></p></td></tr><tr><td><p><span class="stt">without searching.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Examples:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(w/nocase "foobar") "abcFOOBARdef") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(w/nocase "foobar") "FOOBAR") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-data? &lt;obj&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns \scheme{#t} iff the object is a successful match result from</span></p></td></tr><tr><td><p><span class="stt">\scheme{irregex-search} or \scheme{irregex-match}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-num-submatches &lt;irx&gt;)}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-num-submatches &lt;match&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns the number of numbered submatches that are defined in the</span></p></td></tr><tr><td><p><span class="stt">irregex or match object.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-names &lt;irx&gt;)}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-names &lt;match&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns an association list of named submatches that are defined in</span></p></td></tr><tr><td><p><span class="stt">the irregex or match object.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The \scheme{car} of each item in this list is</span></p></td></tr><tr><td><p><span class="stt">the name of a submatch, the \scheme{cdr} of each item is the numerical</span></p></td></tr><tr><td><p><span class="stt">submatch corresponding to this name.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If a named submatch occurs</span></p></td></tr><tr><td><p><span class="stt">multiple times in the irregex, it will also occur multiple times in</span></p></td></tr><tr><td><p><span class="stt">this list.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-valid-index? &lt;match&gt; &lt;index-or-name&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns \scheme{#t} iff the \scheme{index-or-name} named submatch or index is</span></p></td></tr><tr><td><p><span class="stt">defined in the \scheme{match} object.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-substring &lt;match&gt; [&lt;index-or-name&gt;])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-start-index &lt;match&gt; [&lt;index-or-name&gt;])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-end-index &lt;match&gt; [&lt;index-or-name&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Fetches the matched substring (or its start or end offset) at the</span></p></td></tr><tr><td><p><span class="stt">given submatch index, or named submatch.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The entire match is index 0,</span></p></td></tr><tr><td><p><span class="stt">the first 1, etc.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The default is index 0.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match-subchunk &lt;match&gt; [&lt;index-or-name&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Generates a chunked data-type for the given match item, of the same</span></p></td></tr><tr><td><p><span class="stt">type as the underlying chunk type (see Chunked String Matching below).</span></p></td></tr><tr><td><p><span class="stt">This is only available if the chunk type specifies the get-subchunk</span></p></td></tr><tr><td><p><span class="stt">API, otherwise an error is raised.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-replace &lt;irx&gt; &lt;str&gt; [&lt;replacements&gt; ...])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-replace/all &lt;irx&gt; &lt;str&gt; [&lt;replacements&gt; ...])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Matches a pattern in a string, and replaces it with a (possibly empty)</span></p></td></tr><tr><td><p><span class="stt">list of substitutions.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Each \scheme{&lt;replacement&gt;} can be either a string</span></p></td></tr><tr><td><p><span class="stt">literal, a numeric index, a symbol (as a named submatch), or a</span></p></td></tr><tr><td><p><span class="stt">procedure which takes one argument (the match object) and returns a</span></p></td></tr><tr><td><p><span class="stt">string.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Examples:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-replace "[aeiou]" "hello world" "*") =&gt; "h*llo world"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-replace/all "[aeiou]" "hello world" "*") =&gt; "h*ll* w*rld"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-replace/all '(* "poo ") "poo poo platter" "*") =&gt; "**p*l*a*t*t*e*r"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-split &lt;irx&gt; &lt;str&gt; [&lt;start&gt; &lt;end&gt;])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-extract &lt;irx&gt; &lt;str&gt; [&lt;start&gt; &lt;end&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\scheme{irregex-split} splits the string \scheme{&lt;str&gt;} into substrings divided</span></p></td></tr><tr><td><p><span class="stt">by the pattern in \scheme{&lt;irx&gt;}.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{irregex-extract} does the opposite,</span></p></td></tr><tr><td><p><span class="stt">returning a list of each instance of the pattern matched disregarding</span></p></td></tr><tr><td><p><span class="stt">the substrings in between.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Empty matches will result in subsequent single character string in</span></p></td></tr><tr><td><p><span class="stt">\scheme{irregex-split}, or empty strings in \scheme{irregex-extract}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-split "[aeiou]*" "foobarbaz") =&gt; '("f" "b" "r" "b" "z")}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-extract "[aeiou]*" "foobarbaz") =&gt; '("" "oo" "" "a" "" "" "a" "")}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-fold &lt;irx&gt; &lt;kons&gt; &lt;knil&gt; &lt;str&gt; [&lt;finish&gt; &lt;start&gt; &lt;end&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">This performs a fold operation over every non-overlapping place</span></p></td></tr><tr><td><p><span class="stt">\scheme{&lt;irx&gt;} occurs in the string \scheme{str}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The \scheme{&lt;kons&gt;} procedure takes the following signature:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;kons&gt; &lt;from-index&gt; &lt;match&gt; &lt;seed&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">where \scheme{&lt;from-index&gt;} is the index from where we started searching</span></p></td></tr><tr><td><p><span class="stt">(initially \scheme{&lt;start&gt;} and thereafter the end index of the last</span></p></td></tr><tr><td><p><span class="stt">match), \scheme{&lt;match&gt;} is the resulting match-data object, and \scheme{&lt;seed&gt;}</span></p></td></tr><tr><td><p><span class="stt">is the accumulated fold result starting with \scheme{&lt;knil&gt;}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The rationale for providing the \scheme{&lt;from-index&gt;} (which is not</span></p></td></tr><tr><td><p><span class="stt">provided in the SCSH \scheme{regexp-fold} utility), is because this</span></p></td></tr><tr><td><p><span class="stt">information is useful (e.g. for extracting the unmatched portion of</span></p></td></tr><tr><td><p><span class="stt">the string before the current match, as needed in</span></p></td></tr><tr><td><p><span class="stt">\scheme{irregex-replace/all}), and not otherwise directly accessible.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Note when the pattern matches an empty string, to avoid an infinite</span></p></td></tr><tr><td><p><span class="stt">loop we continue from one char after the end of the match (as opposed</span></p></td></tr><tr><td><p><span class="stt">to the end in the normal case).</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The \scheme{&lt;from-index&gt;} passed to</span></p></td></tr><tr><td><p><span class="stt">the subsequent \scheme{&lt;kons&gt;} or \scheme{&lt;finish&gt;} still refers to</span></p></td></tr><tr><td><p><span class="stt">the original previous match end, however, so \scheme{irregex-split}</span></p></td></tr><tr><td><p><span class="stt">and \scheme{irregex-replace/all}, etc. do the right thing.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The optional \scheme{&lt;finish&gt;} takes two arguments:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;finish&gt; &lt;from-index&gt; &lt;seed&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">which similarly allows you to pick up the unmatched tail of the string,</span></p></td></tr><tr><td><p><span class="stt">and defaults to just returning the \scheme{&lt;seed&gt;}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\scheme{&lt;start&gt;} and \scheme{&lt;end&gt;} are numeric indices letting you specify the</span></p></td></tr><tr><td><p><span class="stt">boundaries of the string on which you want to fold.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">To extract all instances of a match out of a string, you can use</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\schemeblock{</span></p></td></tr><tr><td><p><span class="stt">(map irregex-match-substring</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(irregex-fold &lt;irx&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(lambda (i m s) (cons m s))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">'()</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&lt;str&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(lambda (i s) (reverse s))))}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Note if an empty match is found \scheme{&lt;kons&gt;} will be called on that</span></p></td></tr><tr><td><p><span class="stt">empty string, and to avoid an infinite loop matching will resume at</span></p></td></tr><tr><td><p><span class="stt">the next char.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">It is up to the programmer to do something sensible</span></p></td></tr><tr><td><p><span class="stt">with the skipped char in this case.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsection{Extended SRE Syntax}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Irregex provides the first native implementation of SREs (Scheme</span></p></td></tr><tr><td><p><span class="stt">Regular Expressions), and includes many extensions necessary both for</span></p></td></tr><tr><td><p><span class="stt">minimal POSIX compatibility, as well as for modern extensions found in</span></p></td></tr><tr><td><p><span class="stt">libraries such as PCRE.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The following table summarizes the SRE syntax, with detailed</span></p></td></tr><tr><td><p><span class="stt">explanations following.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\pre{\scheme{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; basic patterns</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">&lt;string&gt;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; literal string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(seq &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; sequence</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(: &lt;sre&gt; ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(or &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; alternation</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; optional/multiple patterns</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(? &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; 0 or 1 matches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(* &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; 0 or more matches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(+ &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; 1 or more matches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(= &lt;n&gt; &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; exactly &lt;n&gt; matches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(&gt;= &lt;n&gt; &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; &lt;n&gt; or more matches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(** &lt;from&gt; &lt;to&gt; &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; &lt;n&gt; to &lt;m&gt; matches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(?? &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; non-greedy (non-greedy) pattern: (0 or 1)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(*? &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; non-greedy kleene star</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(**? &lt;from&gt; &lt;to&gt; &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; non-greedy range</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; submatch patterns</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(submatch &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; numbered submatch</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">($ &lt;sre&gt; ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(submatch-named &lt;name&gt; &lt;sre&gt; ...) ; named submatch</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(=&gt; &lt;name&gt; &lt;sre&gt; ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(backref &lt;n-or-name&gt;)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; match a previous submatch</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; toggling case-sensitivity</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(w/case &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; enclosed &lt;sre&gt;s are case-sensitive</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(w/nocase &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; enclosed &lt;sre&gt;s are case-insensitive</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; character sets</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">&lt;char&gt;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; singleton char set</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(&lt;string&gt;)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; set of chars</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(or &lt;cset-sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; set union</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(~ &lt;cset-sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; set complement (i.e. [^...])</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(- &lt;cset-sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; set difference</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(&amp; &lt;cset-sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; set intersection</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(/ &lt;range-spec&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; pairs of chars as ranges</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; named character sets</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">any</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">nonl</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ascii</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">lower-case</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">lower</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">upper-case</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">upper</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">alphabetic</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">alpha</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">numeric</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">num</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">alphanumeric</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">alphanum</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">alnum</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">punctuation</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">punct</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">graphic</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">graph</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">whitespace</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">white</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">space</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">printing</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">print</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">control</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">cntrl</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">hex-digit</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">xdigit</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; assertions and conditionals</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">bos eos</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; beginning/end of string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">bol eol</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; beginning/end of line</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">bow eow</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; beginning/end of word</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">nwb</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; non-word-boundary</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(look-ahead &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; zero-width look-ahead assertion</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(look-behind &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; zero-width look-behind assertion</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(neg-look-ahead &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; zero-width negative look-ahead assertion</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(neg-look-behind &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; zero-width negative look-behind assertion</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(atomic &lt;sre&gt; ...)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; for (?&gt;...) independent patterns</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(if &lt;test&gt; &lt;pass&gt; [&lt;fail&gt;])</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; conditional patterns</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">commit</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; don't backtrack beyond this (i.e. cut)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; backwards compatibility</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(posix-string &lt;string&gt;)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; embed a POSIX string literal</span></p></td></tr><tr><td><p><span class="stt">}}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{Basic SRE Patterns}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The simplest SRE is a literal string, which matches that string</span></p></td></tr><tr><td><p><span class="stt">exactly.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search "needle" "hayneedlehay") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">By default the match is case-sensitive, though you can control this</span></p></td></tr><tr><td><p><span class="stt">either with the compiler flags or local overrides:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search "needle" "haynEEdlehay") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search (irregex "needle" 'i) "haynEEdlehay") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(w/nocase "needle") "haynEEdlehay") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">You can use \scheme{w/case} to switch back to case-sensitivity inside a</span></p></td></tr><tr><td><p><span class="stt">\scheme{w/nocase} or when the SRE was compiled with \scheme{'i}:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(w/nocase "SMALL" (w/case "BIG")) "smallBIGsmall") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(w/nocase "small" (w/case "big")) "smallBIGsmall") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\b{Important:} characters outside the ASCII range are only matched</span></p></td></tr><tr><td><p><span class="stt">case insensitively if the host Scheme system natively supports UTF8 in</span></p></td></tr><tr><td><p><span class="stt">strings.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Of course, literal strings by themselves aren't very interesting</span></p></td></tr><tr><td><p><span class="stt">regular expressions, so we want to be able to compose them.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The most</span></p></td></tr><tr><td><p><span class="stt">basic way to do this is with the \scheme{seq} operator (or its abbreviation</span></p></td></tr><tr><td><p><span class="stt">\scheme{:}), which matches one or more patterns consecutively:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "one" space "two" space "three") "one two three") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">As you may have noticed above, the \scheme{w/case} and \scheme{w/nocase}</span></p></td></tr><tr><td><p><span class="stt">operators allowed multiple SREs in a sequence - other operators that</span></p></td></tr><tr><td><p><span class="stt">take any number of arguments (e.g. the repetition operators below)</span></p></td></tr><tr><td><p><span class="stt">allow such implicit sequences.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">To match any one of a set of patterns use the \scheme{or} alternation</span></p></td></tr><tr><td><p><span class="stt">operator:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(or "eeney" "meeney" "miney") "meeney") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(or "eeney" "meeney" "miney") "moe") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{SRE Repetition Patterns}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There are also several ways to control the number of times a pattern</span></p></td></tr><tr><td><p><span class="stt">is matched.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The simplest of these is \scheme{?} which just optionally</span></p></td></tr><tr><td><p><span class="stt">matches the pattern:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "match" (? "es") "!") "matches!") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "match" (? "es") "!") "match!") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "match" (? "es") "!") "matche!") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">To optionally match any number of times, use \scheme{*}, the Kleene star:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (* (~ #\\&gt;)) "&gt;") "&lt;html&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (* (~ #\\&gt;)) "&gt;") "&lt;&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (* (~ #\\&gt;)) "&gt;") "&lt;html") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Often you want to match any number of times, but at least one time is</span></p></td></tr><tr><td><p><span class="stt">required, and for that you use \scheme{+}:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (+ (~ #\\&gt;)) "&gt;") "&lt;html&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (+ (~ #\\&gt;)) "&gt;") "&lt;a&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (+ (~ #\\&gt;)) "&gt;") "&lt;&gt;") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">More generally, to match at least a given number of times, use \scheme{&gt;=}:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (&gt;= 3 (~ #\\&gt;)) "&gt;") "&lt;table&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (&gt;= 3 (~ #\\&gt;)) "&gt;") "&lt;pre&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (&gt;= 3 (~ #\\&gt;)) "&gt;") "&lt;tr&gt;") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">To match a specific number of times exactly, use \scheme{=}:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (= 4 (~ #\\&gt;)) "&gt;") "&lt;html&gt;") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "&lt;" (= 4 (~ #\\&gt;)) "&gt;") "&lt;table&gt;") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">And finally, the most general form is \scheme{**} which specifies a range</span></p></td></tr><tr><td><p><span class="stt">of times to match.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">All of the earlier forms are special cases of this.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: (= 3 (** 1 3 numeric) ".") (** 1 3 numeric)) "192.168.1.10") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: (= 3 (** 1 3 numeric) ".") (** 1 3 numeric)) "192.0168.1.10") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There are also so-called "non-greedy" variants of these repetition</span></p></td></tr><tr><td><p><span class="stt">operators, by convention suffixed with an additional \scheme{?}.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Since the</span></p></td></tr><tr><td><p><span class="stt">normal repetition patterns can match any of the allotted repetition</span></p></td></tr><tr><td><p><span class="stt">range, these operators will match a string if and only if the normal</span></p></td></tr><tr><td><p><span class="stt">versions matched.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">However, when the endpoints of which submatch</span></p></td></tr><tr><td><p><span class="stt">matched where are taken into account (specifically, all matches when</span></p></td></tr><tr><td><p><span class="stt">using irregex-search since the endpoints of the match itself matter),</span></p></td></tr><tr><td><p><span class="stt">the use of a non-greedy repetition can change the result.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">So, whereas \scheme{?} can be thought to mean "match or don't match,"</span></p></td></tr><tr><td><p><span class="stt">\scheme{??} means "don't match or match."</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{*} typically consumes as much</span></p></td></tr><tr><td><p><span class="stt">as possible, but \scheme{*?} tries first to match zero times, and only</span></p></td></tr><tr><td><p><span class="stt">consumes one at a time if that fails.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If you have a greedy operator</span></p></td></tr><tr><td><p><span class="stt">followed by a non-greedy operator in the same pattern, they can</span></p></td></tr><tr><td><p><span class="stt">produce surprisins results as they compete to make the match longer or</span></p></td></tr><tr><td><p><span class="stt">shorter.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If this seems confusing, that's because it is.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Non-greedy</span></p></td></tr><tr><td><p><span class="stt">repetitions are defined only in terms of the specific backtracking</span></p></td></tr><tr><td><p><span class="stt">algorithm used to implement them, which for compatibility purposes</span></p></td></tr><tr><td><p><span class="stt">always means the Perl algorithm.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Thus, when using these patterns you</span></p></td></tr><tr><td><p><span class="stt">force IrRegex to use a backtracking engine, and can't rely on</span></p></td></tr><tr><td><p><span class="stt">efficient execution.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{SRE Character Sets}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Perhaps more common than matching specific strings is matching any of</span></p></td></tr><tr><td><p><span class="stt">a set of characters.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">You can use the \scheme{or} alternation pattern on a</span></p></td></tr><tr><td><p><span class="stt">list of single-character strings to simulate a character set, but this</span></p></td></tr><tr><td><p><span class="stt">is too clumsy for everyday use so SRE syntax allows a number of</span></p></td></tr><tr><td><p><span class="stt">shortcuts.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">A single character matches that character literally, a trivial</span></p></td></tr><tr><td><p><span class="stt">character class.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">More conveniently, a list holding a single element</span></p></td></tr><tr><td><p><span class="stt">which is a string refers to the character set composed of every</span></p></td></tr><tr><td><p><span class="stt">character in the string.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* #\\-) "---") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* #\\-) "-_-") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* ("aeiou")) "oui") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* ("aeiou")) "ouais") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Ranges are introduced with the \scheme{/} operator.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Any strings or</span></p></td></tr><tr><td><p><span class="stt">characters in the \scheme{/} are flattened and then taken in pairs to</span></p></td></tr><tr><td><p><span class="stt">represent the start and end points, inclusive, of character ranges.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* (/ "AZ09")) "R2D2") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* (/ "AZ09")) "C-3PO") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">In addition, a number of set algebra operations are provided.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{or},</span></p></td></tr><tr><td><p><span class="stt">of course, has the same meaning, but when all the options are</span></p></td></tr><tr><td><p><span class="stt">character sets it can be thought of as the set union operator.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">This</span></p></td></tr><tr><td><p><span class="stt">is further extended by the \scheme{&amp;} set intersection, \scheme{-} set</span></p></td></tr><tr><td><p><span class="stt">difference, and \scheme{~} set complement operators.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* (&amp; (/ "az") (~ ("aeiou")))) "xyzzy") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* (&amp; (/ "az") (~ ("aeiou")))) "vowels") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* (- (/ "az") ("aeiou"))) "xyzzy") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-match '(* (- (/ "az") ("aeiou"))) "vowels") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{SRE Assertion Patterns}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There are a number of times it can be useful to assert something about</span></p></td></tr><tr><td><p><span class="stt">the area around a pattern without explicitly making it part of the</span></p></td></tr><tr><td><p><span class="stt">pattern.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The most common cases are specifically anchoring some</span></p></td></tr><tr><td><p><span class="stt">pattern to the beginning or end of a word or line or even the whole</span></p></td></tr><tr><td><p><span class="stt">string.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">For example, to match on the end of a word:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "foo" eow) "foo") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "foo" eow) "foo!") =&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "foo" eow) "foof") =&gt; #f}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The \scheme{bow}, \scheme{bol}, \scheme{eol}, \scheme{bos} and \scheme{eos} work similarly.</span></p></td></tr><tr><td><p><span class="stt">\scheme{nwb} asserts that you are not in a word-boundary - if replaced for</span></p></td></tr><tr><td><p><span class="stt">\scheme{eow} in the above examples it would reverse all the results.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There is no \scheme{wb}, since you tend to know from context whether it</span></p></td></tr><tr><td><p><span class="stt">would be the beginning or end of a word, but if you need it you can</span></p></td></tr><tr><td><p><span class="stt">always use \scheme{(or bow eow)}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Somewhat more generally, Perl introduced positive and negative</span></p></td></tr><tr><td><p><span class="stt">look-ahead and look-behind patterns.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Perl look-behind patterns are</span></p></td></tr><tr><td><p><span class="stt">limited to a fixed length, however the IrRegex versions have no such</span></p></td></tr><tr><td><p><span class="stt">limit.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(irregex-search '(: "regular" (look-ahead " expression"))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"regular expression")</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">=&gt; #&lt;match&gt;}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The most general case, of course, would be an \scheme{and} pattern to</span></p></td></tr><tr><td><p><span class="stt">complement the \scheme{or} pattern - all the patterns must match or the</span></p></td></tr><tr><td><p><span class="stt">whole pattern fails.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">This may be provided in a future release,</span></p></td></tr><tr><td><p><span class="stt">although it (and look-ahead and look-behind assertions) are unlikely</span></p></td></tr><tr><td><p><span class="stt">to be compiled efficiently.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{SRE Utility Patterns}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The following utility regular expressions are also provided for common</span></p></td></tr><tr><td><p><span class="stt">patterns that people are eternally reinventing.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">They are not</span></p></td></tr><tr><td><p><span class="stt">necessarily the official patterns matching the RFC definitions of the</span></p></td></tr><tr><td><p><span class="stt">given data, because of the way that such patterns tend to be used.</span></p></td></tr><tr><td><p><span class="stt">There are three general usages for regexps:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\item*{searching} - search for a pattern matching a desired object in a larger text</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\item*{validation} - determine whether an entire string matches a pattern</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\item*{extraction} - given a string already known to be valid, extract certain fields from it as submatches</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">In some cases, but not always, these will overlap.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">When they are</span></p></td></tr><tr><td><p><span class="stt">different, \scheme{irregex-search} will naturally always want the searching</span></p></td></tr><tr><td><p><span class="stt">version, so IrRegex provides that version.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">As an example where these might be different, consider a URL.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">If you</span></p></td></tr><tr><td><p><span class="stt">want to match all the URLs in some arbitrary text, you probably want</span></p></td></tr><tr><td><p><span class="stt">to exclude a period or comma at the tail end of a URL, since it's more</span></p></td></tr><tr><td><p><span class="stt">likely being used as punctuation rather than part of the URL, despite</span></p></td></tr><tr><td><p><span class="stt">the fact that it would be valid URL syntax.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Another problem with the RFC definitions is the standard itself may</span></p></td></tr><tr><td><p><span class="stt">have become irrelevant.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">For example, the pattern IrRegex provides for</span></p></td></tr><tr><td><p><span class="stt">email addresses doesn't match quoted local parts (e.g.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"first</span></p></td></tr><tr><td><p><span class="stt">last"@domain.com) because these are increasingly rare, and unsupported</span></p></td></tr><tr><td><p><span class="stt">by enough software that it's better to discourage their use.</span></p></td></tr><tr><td><p><span class="stt">Conversely, technically consecutive periods</span></p></td></tr><tr><td><p><span class="stt">(e.g. first..last@domain.com) are not allowed in email addresses, but</span></p></td></tr><tr><td><p><span class="stt">most email software does allow this, and in fact such addresses are</span></p></td></tr><tr><td><p><span class="stt">quite common in Japan.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The current patterns provided are:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\pre{\scheme{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">newline</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; general newline pattern (crlf, cr, lf)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">integer</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; an integer</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">real</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a real number (including scientific)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">string</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a "quoted" string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">symbol</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; an R5RS Scheme symbol</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ipv4-address</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a numeric decimal ipv4 address</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ipv6-address</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a numeric hexadecimal ipv6 address</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">domain</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a domain name</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">domain/common</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a domain ending in a common TLD like .com</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">email</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; an email address</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">http-url</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; a URL beginning with https?://</span></p></td></tr><tr><td><p><span class="stt">}}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Because of these issues the exact definitions of these patterns are</span></p></td></tr><tr><td><p><span class="stt">subject to be changed, but will be documented clearly when they are</span></p></td></tr><tr><td><p><span class="stt">finalized.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">More common patterns are also planned, but as what you</span></p></td></tr><tr><td><p><span class="stt">want increases in complexity it's probably better to use a real</span></p></td></tr><tr><td><p><span class="stt">parser.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsection{Supported PCRE Syntax}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Since the PCRE syntax is so overwhelming complex, it's easier to just</span></p></td></tr><tr><td><p><span class="stt">list what we *don't* support for now.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Refer to the</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://pcre.org/pcre.txt]{PCRE documentation} for details.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">You</span></p></td></tr><tr><td><p><span class="stt">should be using the SRE syntax anyway!</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Unicode character classes (\\P) are not supported, but will be</span></p></td></tr><tr><td><p><span class="stt">in an upcoming release.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\\C named characters are not supported.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Callbacks, subroutine patterns and recursive patterns are not</span></p></td></tr><tr><td><p><span class="stt">supported.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(*FOO) patterns are not supported and may never be.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\\G and \\K are not supported.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Octal character escapes are not supported because they are ambiguous</span></p></td></tr><tr><td><p><span class="stt">with back-references - just use hex character escapes.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Other than that everything should work, including named submatches,</span></p></td></tr><tr><td><p><span class="stt">zero-width assertions, conditional patterns, etc.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">In addition, \\&lt; and \\&gt; act as beginning-of-word and end-of-word marks,</span></p></td></tr><tr><td><p><span class="stt">respectively, as in Emacs regular expressions.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Also, two escapes are provided to embed SRE patterns inside PCRE</span></p></td></tr><tr><td><p><span class="stt">strings, "\\'&lt;sre&gt;" and "(*'&lt;sre&gt;)".</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">For example, to match a</span></p></td></tr><tr><td><p><span class="stt">comma-delimited list of integers you could use</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"\\\\'integer(,\\\\'integer)*"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">and to match a URL in angle brackets you could use</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"&lt;('*http-url)&gt;"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Note in the second example the enclosing "('*...)" syntax is needed</span></p></td></tr><tr><td><p><span class="stt">because the Scheme reader would consider the closing "&gt;" as part of</span></p></td></tr><tr><td><p><span class="stt">the SRE symbol.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The following chart gives a quick reference from PCRE form to the SRE</span></p></td></tr><tr><td><p><span class="stt">equivalent:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\schemeblock{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; basic syntax</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"^"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; bos (or eos inside (?m: ...))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"$"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; eos (or eos inside (?m: ...))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"."</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; nonl</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a?"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (? a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a*"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (* a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a+"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (+ a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a??"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (?? a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a*?"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (*? a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a+?"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (+? a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"a{n,m}"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (** n m a)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; grouping</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (submatch ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?:...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (: ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?i:...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (w/nocase ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?-i:...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (w/case ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?&lt;name&gt;...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (=&gt; &lt;name&gt;...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; character classes</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"[aeiou]"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; ("aeiou")</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"[^aeiou]"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (~ "aeiou")</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"[a-z]"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (/ "az") or (/ "a" "z")</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"[[:alpha:]]"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; alpha</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; assertions</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?=...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (look-ahead ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?!...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (neg-look-ahead ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?&lt;=...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (look-behind ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?&lt;!...)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (neg-look-behind ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(?(test)pass|fail)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; (if test pass fail)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"(*COMMIT)"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">;; commit</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsection{Chunked String Matching}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">It's often desirable to perform regular expression matching over</span></p></td></tr><tr><td><p><span class="stt">sequences of characters not represented as a single string.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">The most</span></p></td></tr><tr><td><p><span class="stt">obvious example is a text-buffer data structure, but you may also want</span></p></td></tr><tr><td><p><span class="stt">to match over lists or trees of strings (i.e. ropes), over only</span></p></td></tr><tr><td><p><span class="stt">certain ranges within a string, over an input port, etc.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">With</span></p></td></tr><tr><td><p><span class="stt">existing regular expression libraries, the only way to accomplish this</span></p></td></tr><tr><td><p><span class="stt">is by converting the abstract sequence into a freshly allocated</span></p></td></tr><tr><td><p><span class="stt">string.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">This can be expensive, or even impossible if the object is a</span></p></td></tr><tr><td><p><span class="stt">text-buffer opened onto a 500MB file.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">IrRegex provides a chunked string API specifically for this purpose.</span></p></td></tr><tr><td><p><span class="stt">You define a chunking API with</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(make-irregex-chunker &lt;get-next&gt; &lt;get-string&gt; [&lt;get-start&gt; &lt;get-end&gt; &lt;get-substring&gt; &lt;get-subchunk&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">where </span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;get-next&gt; chunk) =&gt; } returns the next chunk, or \scheme{#f} if there are no more chunks</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;get-string&gt; chunk) =&gt; } a string source for the chunk</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;get-start&gt; chunk) =&gt; } the start index of the result of \scheme{&lt;get-string&gt;} (defaults to always 0)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;get-end&gt; chunk) =&gt; } the end (exclusive) of the string (defaults to \scheme{string-length} of the source string)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;get-substring&gt; cnk1 i cnk2 j) =&gt; } a substring for the range between the chunk \scheme{cnk1} starting at index \scheme{i} and ending at \scheme{cnk2} at index \scheme{j}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{(&lt;get-subchunk&gt; cnk1 i cnk2 j) =&gt; } as above but returns a new chunked data type instead of a string (optional)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">There are two important constraints on the \scheme{&lt;get-next&gt;} procedure.</span></p></td></tr><tr><td><p><span class="stt">It must return an \scheme{eq?} identical object when called multiple times</span></p></td></tr><tr><td><p><span class="stt">on the same chunk, and it must not return a chunk with an empty string</span></p></td></tr><tr><td><p><span class="stt">(start == end).</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">This second constraint is for performance reasons -</span></p></td></tr><tr><td><p><span class="stt">we push the work of possibly filtering empty chunks to the chunker</span></p></td></tr><tr><td><p><span class="stt">since there are many chunk types for which empty strings aren't</span></p></td></tr><tr><td><p><span class="stt">possible, and this work is thus not needed.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Note that the initial</span></p></td></tr><tr><td><p><span class="stt">chunk passed to match on is allowed to be empty.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\scheme{&lt;get-substring&gt;} is provided for possible performance improvements</span></p></td></tr><tr><td><p><span class="stt">- without it a default is used.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\scheme{&lt;get-subchunk&gt;} is optional -</span></p></td></tr><tr><td><p><span class="stt">without it you may not use \scheme{irregex-match-subchunk} described above.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">You can then match chunks of these types with the following</span></p></td></tr><tr><td><p><span class="stt">procedures:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-search/chunked &lt;irx&gt; &lt;chunker&gt; &lt;chunk&gt; [&lt;start&gt;])}</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-match/chunked &lt;irx&gt; &lt;chunker&gt; &lt;chunk&gt; [&lt;start&gt;])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">These return normal match-data objects.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Example:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">To match against a simple, flat list of strings use:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\schemeblock{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define (rope-&gt;string rope1 start rope2 end)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(if (eq? rope1 rope2)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(substring (car rope1) start end)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(let loop ((rope (cdr rope1))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(res (list (substring (car rope1) start))))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(if (eq? rope rope2)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(string-concatenate-reverse</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; from SRFI-13</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(cons (substring (car rope) 0 end) res))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(loop (cdr rope) (cons (car rope) res))))))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define rope-chunker</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(make-irregex-chunker (lambda (x) (and (pair? (cdr x)) (cdr x)))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">car</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(lambda (x) 0)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(lambda (x) (string-length (car x)))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">rope-&gt;string))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(irregex-search/chunked &lt;pat&gt; rope-chunker &lt;list-of-strings&gt;)</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Here we are just using the default start, end and substring behaviors,</span></p></td></tr><tr><td><p><span class="stt">so the above chunker could simply be defined as:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\schemeblock{</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(define rope-chunker</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(make-irregex-chunker (lambda (x) (and (pair? (cdr x)) (cdr x))) car))</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-fold/chunked &lt;irx&gt; &lt;kons&gt; &lt;knil&gt; &lt;chunker&gt; &lt;chunk&gt; [&lt;finish&gt; [&lt;start-index&gt;]])}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Chunked version of \scheme{irregex-fold}.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsection{Utilities}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">The following procedures are available in irregex-utils.scm.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-quote &lt;str&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns a new string with any special regular expression characters</span></p></td></tr><tr><td><p><span class="stt">escaped, to match the original string literally in POSIX regular</span></p></td></tr><tr><td><p><span class="stt">expressions.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(irregex-opt &lt;list-of-strings&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Returns an optimized SRE matching any of the literal strings</span></p></td></tr><tr><td><p><span class="stt">in the list, like Emacs' \scheme{regexp-opt}.</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Note this optimization</span></p></td></tr><tr><td><p><span class="stt">doesn't help when irregex is able to build a DFA.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\subsubsection{(sre-&gt;string &lt;sre&gt;)}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Convert an SRE to a PCRE-style regular expression string, if</span></p></td></tr><tr><td><p><span class="stt">possible.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\section{Roadmap}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0.6</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">- full PCRE support (DONE)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0.7</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">- chunked string API (DONE)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0.8</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">- utilities and API finalization (DONE)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">0.9</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">- refactoring, implementation-specific performance enhancements (DONE)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">1.0</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">- cleanup and better documentation</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\section{License}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Copyright (c) 2005-2021 Alex Shinn</span></p></td></tr><tr><td><p><span class="stt">All rights reserved.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Redistribution and use in source and binary forms, with or without</span></p></td></tr><tr><td><p><span class="stt">modification, are permitted provided that the following conditions</span></p></td></tr><tr><td><p><span class="stt">are met:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">1. Redistributions of source code must retain the above copyright</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">notice, this list of conditions and the following disclaimer.</span></p></td></tr><tr><td><p><span class="stt">2. Redistributions in binary form must reproduce the above copyright</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">notice, this list of conditions and the following disclaimer in the</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">documentation and/or other materials provided with the distribution.</span></p></td></tr><tr><td><p><span class="stt">3. The name of the author may not be used to endorse or promote products</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">derived from this software without specific prior written permission.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</span></p></td></tr><tr><td><p><span class="stt">IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span></p></td></tr><tr><td><p><span class="stt">OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span></p></td></tr><tr><td><p><span class="stt">IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span></p></td></tr><tr><td><p><span class="stt">INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span></p></td></tr><tr><td><p><span class="stt">NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></p></td></tr><tr><td><p><span class="stt">DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></p></td></tr><tr><td><p><span class="stt">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></p></td></tr><tr><td><p><span class="stt">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span></p></td></tr><tr><td><p><span class="stt">THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\section{References}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{R5RS} R. Kelsey, W. Clinger, J. Rees (eds.)</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://www.schemers.org/Documents/Standards/R5RS/]{Revised^5 Report on the Algorithmic Language Scheme}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{ImplementingRegexps} Russ Cox</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://swtch.com/~rsc/regexp/]{Implementing Regular Expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{Tcl} Russ Cox</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://compilers.iecc.com/comparch/article/07-10-026]{Henry Spencer's Tcl Regex Library}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{SRE} Olin Shivers</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://www.scsh.net/docu/post/sre.html]{Proposed SRE regular-expression notation}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{SCSH} Olin Shivers</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://www.scsh.net/docu/html/man-Z-H-7.html]{Pattern-matching strings with regular expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{Gauche} Shiro Kawai</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://practical-scheme.net/gauche/man/gauche-refe_49.html]{Gauche Scheme - Regular Expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{Perl6} Damian Conway</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://www.perl.com/pub/a/2002/08/22/exegesis5.html]{Perl6 Exegesis 5 - Regular Expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{PCRE} Philip Hazel</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://www.pcre.org/]{PCRE - Perl Compatible Regular Expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{tNFAs} Ville Laurikari</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://laurikari.net/ville/spire2000-tnfa.pdf]{NFAs with Tagged Transitions, their Conversion to Deterministic Automata and Application to Regular Expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">\bibitem{RegexpSubmatches} Ville Laurikari</span></p></td></tr><tr><td><p><span class="stt">\hyperlink[http://laurikari.net/ville/regex-submatch.pdf]{Efficient submatch addressing for regular expressions}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr></table></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.6&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body>
<!-- Mirrored from docs.racket-lang.org/irregex/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 07 Sep 2022 03:01:55 GMT -->
</html>