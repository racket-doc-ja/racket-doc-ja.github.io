<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Mirrored from docs.racket-lang.org/ruckus/Internals.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 07 Sep 2022 03:30:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>5&nbsp;Internals</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Ruckus:<span class="mywbr"> &nbsp;</span> Procedural CAD For Weirdos</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="prerequisites.html" class="tocviewlink" data-pltdoc="x">Prerequisites</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Getting_Your_Ruckus_On.html" class="tocviewlink" data-pltdoc="x">Getting Your Ruckus On</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Ruckus_Language_Reference.html" class="tocviewlink" data-pltdoc="x">Ruckus Language Reference</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="The_Ruckus_Tools.html" class="tocviewlink" data-pltdoc="x">The Ruckus Tools</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#" class="tocviewselflink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>5&nbsp;</td><td><a href="#" class="tocviewselflink" data-pltdoc="x">Internals</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">5.1&nbsp;</td><td><a href="#%28part._.The_.Math_.Bits%29" class="tocviewlink" data-pltdoc="x">The Math Bits</a></td></tr><tr><td align="right">5.2&nbsp;</td><td><a href="#%28part._.The_.Ruckus_.Compiler%29" class="tocviewlink" data-pltdoc="x">The Ruckus Compiler</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Math_.Bits%29" class="tocsubseclink" data-pltdoc="x">The Math Bits</a></td></tr><tr><td><span class="tocsublinknumber">5.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Implicit_.Surfaces_and_the_.Function_.Representation%29" class="tocsubseclink" data-pltdoc="x">Implicit Surfaces and the Function Representation</a></td></tr><tr><td><span class="tocsublinknumber">5.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Signed_.Distance_.Fields%29" class="tocsubseclink" data-pltdoc="x">Signed Distance Fields</a></td></tr><tr><td><span class="tocsublinknumber">5.1.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Lipschitz_.Criterion%29" class="tocsubseclink" data-pltdoc="x">The Lipschitz Criterion</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Ruckus_.Compiler%29" class="tocsubseclink" data-pltdoc="x">The Ruckus Compiler</a></td></tr><tr><td><span class="tocsublinknumber">5.2.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Ruckus_.Language_.Module%29" class="tocsubseclink" data-pltdoc="x">The Ruckus Language Module</a></td></tr><tr><td><span class="tocsublinknumber">5.2.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Rewrite_.Example%29" class="tocsubseclink" data-pltdoc="x">Rewrite Example</a></td></tr><tr><td><span class="tocsublinknumber">5.2.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Using_.Another_.Racket_.Language%29" class="tocsubseclink" data-pltdoc="x">Using Another Racket Language</a></td></tr><tr><td><span class="tocsublinknumber">5.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Building_the_.A.S.T%29" class="tocsubseclink" data-pltdoc="x">Building the AST</a></td></tr><tr><td><span class="tocsublinknumber">5.2.2.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.A.S.T_.Node_.Structure%29" class="tocsubseclink" data-pltdoc="x">The AST Node Structure</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fmodel..rkt%29._node%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">node</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.2.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.E.D.S.L_.Evaluator%29" class="tocsubseclink" data-pltdoc="x">The EDSL Evaluator</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Flang%2Fevaluator..rkt%29._call-with-edsl-root%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">call-<wbr></wbr>with-<wbr></wbr>edsl-<wbr></wbr>root</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.3<tt>&nbsp;</tt></span><a href="#%28part._.A.S.T_.Rewriting%29" class="tocsubseclink" data-pltdoc="x">AST Rewriting</a></td></tr><tr><td><span class="tocsublinknumber">5.2.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Canonicalization%29" class="tocsubseclink" data-pltdoc="x">Canonicalization</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fcompiler%2Fcanon..rkt%29._canonicalize%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">canonicalize</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Enumeration%29" class="tocsubseclink" data-pltdoc="x">Enumeration</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fcompiler%2Fenumerate..rkt%29._enumerate-nodes%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">enumerate-<wbr></wbr>nodes</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.4<tt>&nbsp;</tt></span><a href="#%28part._.Lowering_to_.Ruckus_.I.R%29" class="tocsubseclink" data-pltdoc="x">Lowering to Ruckus IR</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fcompiler%2Flower..rkt%29._generate-statements%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">generate-<wbr></wbr>statements</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.4.1<tt>&nbsp;</tt></span><a href="#%28part._.Assignments%29" class="tocsubseclink" data-pltdoc="x">Assignments</a></td></tr><tr><td><span class="tocsublinknumber">5.2.4.2<tt>&nbsp;</tt></span><a href="#%28part._.Expressions%29" class="tocsubseclink" data-pltdoc="x">Expressions</a></td></tr><tr><td><span class="tocsublinknumber">5.2.4.3<tt>&nbsp;</tt></span><a href="#%28part._.Value_.Pruning%29" class="tocsubseclink" data-pltdoc="x">Value Pruning</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fcompiler%2Flower..rkt%29._prune-statements%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">prune-<wbr></wbr>statements</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.5<tt>&nbsp;</tt></span><a href="#%28part._.Target_.Backends%29" class="tocsubseclink" data-pltdoc="x">Target Backends</a></td></tr><tr><td><span class="tocsublinknumber">5.2.5.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Racket_.Backend%29" class="tocsubseclink" data-pltdoc="x">The Racket Backend</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fcompiler%2Fracket..rkt%29._node-~3edistance-function%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">node-<wbr></wbr>&gt;distance-<wbr></wbr>function</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fcore%2Fcompiler%2Fracket..rkt%29._node-~3ediscriminator%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">node-<wbr></wbr>&gt;discriminator</span></a></td></tr><tr><td><span class="tocsublinknumber">5.2.5.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.G.L.S.L_.Backend%29" class="tocsubseclink" data-pltdoc="x">The GLSL Backend</a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fviz%2Fglsl..rkt%29._node-~3eglsl-distance%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">node-<wbr></wbr>&gt;glsl-<wbr></wbr>distance</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._ruckus%2Fviz%2Fglsl..rkt%29._node-~3eglsl-disc%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">node-<wbr></wbr>&gt;glsl-<wbr></wbr>disc</span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.6</span></div><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.6&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="The_Ruckus_Tools.html" title="backward to &quot;4 The Ruckus Tools&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Ruckus: Procedural CAD For Weirdos&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Internals&quot;">5<tt>&nbsp;</tt><a name="(part._.Internals)"></a>Internals</h3><h4 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_Math_Bits&quot;">5.1<tt>&nbsp;</tt><a name="(part._.The_.Math_.Bits)"></a>The Math Bits</h4><p>This section goes into detail on how Ruckus represents solid objects
internally, which may help to explain why it behaves the way it does.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Implicit_Surfaces_and_the_Function_Representation&quot;">5.1.1<tt>&nbsp;</tt><a name="(part._.Implicit_.Surfaces_and_the_.Function_.Representation)"></a>Implicit Surfaces and the Function Representation</h5><p>In 3D graphics, surfaces are often represented explicitly by polygons along
their boundary.  This is not the only way to do it.</p><p>An implicit surface (<a href="https://en.wikipedia.org/wiki/Implicit_surface">Wikipedia</a>) is a surface defined by the value
of a field in space.  By a "field," we mean a quantity that is measurable at
every point in space.  In the real world, the quantity might be density or
electrical charge.  Given a field, the implicit surface exists where the field
is zero.</p><p>That was abstract.  Let&rsquo;s consider this in two dimensions.  We can define a
two-dimensional scalar field using an equation that maps X and Y to a number,
such as:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">sqr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sqr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We can graph this equation by using its result as a height level above the XY
plane.</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict.png" alt="image" width="406" height="406"/></p><p>The heightfield intersects and dips beneath the XY plane in the center of the
bowl shape:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_2.png" alt="image" width="406" height="406"/></p><p>The intersection of the heightfield with the XY plane is outlined in the plot
above.  This is the (infinite) set of XY points where our field level is zero.
If we forgo the fancy 3D plot and draw these points on a Cartesian plane, we
get a circle:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_3.png" alt="image" width="406" height="406"/></p><p>The set of points where the field is zero forms a two-dimensional implicit
surface.  One could even say that our equation <span style="font-style: italic">is</span> an implicit circle.
This notion, that of identifying the equation with the surface it represents,
is the <span style="font-style: italic">function representation</span> (<a href="https://en.wikipedia.org/wiki/Function_representation">Wikipedia</a>), or
<span style="font-style: italic">f-rep</span>.  There are other representations of implicit surfaces,
including data structures that directly describe geometric operations, or
discretely sampled grids of field values.</p><p>Ruckus models solid objects using implicit surfaces in the function
representation.</p><p>Because the objects are solid, they are not merely surfaces: they are oriented
surfaces, with a distinct inside and outside.  Specifically, Ruckus takes the
perspective that any negative field value is "inside."  This means that, in our running example, we have not just a circle but a solid disk:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_4.png" alt="image" width="406" height="406"/></p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Signed_Distance_Fields&quot;">5.1.2<tt>&nbsp;</tt><a name="(part._.Signed_.Distance_.Fields)"></a>Signed Distance Fields</h5><p>F-rep is interesting because it makes certain kinds of common operations on
shapes easier: intersection, subtraction, outsetting, filleting, and more.  But
it isn&rsquo;t all roses.  It&rsquo;s cheap to determine whether a given point is on the
surface of an f-rep object &#8212;<wbr></wbr> just evaluate the function &#8212;<wbr></wbr> but going the
other way to find which points are on the surface means finding the function&rsquo;s
roots.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>This class of traversal optimization for signed distance fields
was first described, as far as I can tell, by John C. Hart in his paper
<span style="font-style: italic">Sphere tracing: a geometric method for the antialiased ray tracing of
implicit surfaces</span>
(<a href="http://graphics.cs.illinois.edu/sites/default/files/zeno.pdf">PDF</a>).</p></blockquote></blockquote></blockquote><p>This can be made cheaper for functions with certain characteristics.  In
particular, there is a class of function called a <span style="font-style: italic">signed distance
field</span> that is a subset of the f-rep objects we&rsquo;ve discussed so far.  In a
signed distance field, the field value at a point not only indicates whether
the point is inside, outside, or on the surface of an object &#8212;<wbr></wbr> it also gives
the distance to the nearest point on the object&rsquo;s surface.</p><p>The equation we&rsquo;ve been using so far is not a signed distance field, but we can
alter it slightly so that it becomes one.  Namely, we can make it into the
Euclidean distance metric:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">sqrt</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">sqr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sqr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This measures the length of the vector (x, y) using the Pythagorean theorem,
and subtracts 3 so that the roots appear in a circle exactly three units away
from the origin.  It&rsquo;s a circle with radius 3:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_5.png" alt="image" width="406" height="406"/></p><p>Compared to general f-rep implicit surfaces, signed distance fields allow for
some valuable optimizations.  Sampling the field at any point gives the exact
distance to the nearest surface.  If the field value is positive, one can infer
that there is no solid within a circle (in 2D) or sphere (3D) around the sample
point &#8212;<wbr></wbr> called an <span style="font-style: italic">unbounding sphere</span>.  Algorithms traversing space
hunting for a root can then skip to the border of the unbounding sphere.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>I&#241;igo Quilez has collected a wonderful
<a href="http://iquilezles.org/www/articles/distfunctions/distfunctions.htm">menagerie
of exact signed distance field functions</a> for common primitives.</p></blockquote></blockquote></blockquote><p>While it&rsquo;s possible to analytically construct signed distance fields for many
kinds of objects, it&rsquo;s difficult to maintain a perfect distance field as
objects are transformed, composed, or intersected.  Certain apparently elementary transformations, such as scaling an object along only one axis, cannot be performed on a signed distance field f-rep solid.</p><p>So we have to loosen the rules a little.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_Lipschitz_Criterion&quot;">5.1.3<tt>&nbsp;</tt><a name="(part._.The_.Lipschitz_.Criterion)"></a>The Lipschitz Criterion</h5><p>Consider that a signed distance field works because we can predict its slope
(the magnitude of its gradient vector).  It&rsquo;s exactly one: for every unit we
move away from the surface, the field increases by one.  This means we can
assume that, given a field value <span style="font-style: italic">v = F(x, y)</span>, there are no roots
within <span style="font-style: italic">v</span> units in any direction of the point <span style="font-style: italic">(x, y)</span>.</p><p>A bound on the slope of a field is known as the <span style="font-style: italic">Lipschitz criterion</span>
(<a href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Wikipedia</a>), and a function that is
<span style="font-style: italic">Lipschitz-continuous</span> has a definite bound on its slope called its
<span style="font-style: italic">Lipschitz number</span>.  It&rsquo;s usually written as a lowercase lambda (&#955;) but
in the Ruckus sources, it&rsquo;s written <span class="stt">L</span>.</p><p>A signed distance field has Lipschitz number 1.  The optimization described
above actually applies to any field with Lipschitz number <span style="font-style: italic">between zero
and one</span>.  It relies on the ability to derive an unbounding sphere for any
point in space, so that it can skip forward with no risk of missing a surface.
But it remains correct, if not quite as optimal, if we can only derive a
<span style="font-style: italic">conservative underestimate</span> of the unbounding sphere.  In other words,
it&rsquo;s okay if our unbounding spheres are wrong, as long as they&rsquo;re <span style="font-style: italic">too
small</span> rather than too large.  Fields with this property are <span style="font-style: italic">signed
distance bound fields</span>.</p><p>It is difficult to maintain a strict signed distance field under arbitrary
transformations; it is <span style="font-style: italic">much</span> easier to maintain a definite Lipschitz
number in a signed distance bound field.  In Hart&rsquo;s <span style="font-style: italic">Sphere Tracing</span>
paper he presented a set of rules for maintaining Lipschitz continuity across
transformations; more have since been discovered.</p><p>Ruckus represents solids as signed distance bound fields (0 &lt; L &lt;= 1).</p><h4 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_Ruckus_Compiler&quot;">5.2<tt>&nbsp;</tt><a name="(part._.The_.Ruckus_.Compiler)"></a>The Ruckus Compiler</h4><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_Ruckus_Language_Module&quot;">5.2.1<tt>&nbsp;</tt><a name="(part._.The_.Ruckus_.Language_.Module)"></a>The Ruckus Language Module</h5><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Racket has built-in support for stuff like this, which is why I
used it to implement Ruckus in the first place.</p></blockquote></blockquote></blockquote><p>The Ruckus language is implemented as a set of rewrite rules that produce valid
Racket code at the design level.  These rewrite rules are invoked on any file
that starts with:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="Ruckus_Language_Reference.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus</span></a><span class="RktMeta"></span></td></tr></table></blockquote><p>The rewrite rules allow Ruckus forms defining geometry to be used at the
top-level of a Ruckus design language file, while postponing their actual
evaluation so that it doesn&rsquo;t occur during <span class="RktSym">require</span>.  This is handy,
because it&rsquo;s often useful to instantiate an assembly at the top level of a file
so that it can be viewed or exported &#8212;<wbr></wbr> but when it comes time to reuse
portions of that file in a new design, we rarely want the new design to grow
the other file&rsquo;s top-level assembly.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Rewrite_Example&quot;">5.2.1.1<tt>&nbsp;</tt><a name="(part._.Rewrite_.Example)"></a>Rewrite Example</h5><p>Here&rsquo;s an example.  It defines a reusable 2D bolt pattern, and locally defines
an extruded part to demonstrate the pattern for visual checking.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="Ruckus_Language_Reference.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Bolt</span><span class="hspace">&nbsp;</span><span class="RktCmt">parameters,</span><span class="hspace">&nbsp;</span><span class="RktCmt">not</span><span class="hspace">&nbsp;</span><span class="RktCmt">provided</span><span class="hspace">&nbsp;</span><span class="RktCmt">for</span><span class="hspace">&nbsp;</span><span class="RktCmt">other</span><span class="hspace">&nbsp;</span><span class="RktCmt">designs.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">25.4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-diameter</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4.5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Bolt</span><span class="hspace">&nbsp;</span><span class="RktCmt">pattern.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bolt-pattern</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">half-sp</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">/</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">for*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">-1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">y</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">-1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">at</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">half-sp</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">half-sp</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">circle</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">#:diameter</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-diameter</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Publish</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">bolt</span><span class="hspace">&nbsp;</span><span class="RktCmt">pattern</span><span class="hspace">&nbsp;</span><span class="RktCmt">for</span><span class="hspace">&nbsp;</span><span class="RktCmt">reuse</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">provide</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-pattern</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">To</span><span class="hspace">&nbsp;</span><span class="RktCmt">help</span><span class="hspace">&nbsp;</span><span class="RktCmt">visualize</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">pattern,</span><span class="hspace">&nbsp;</span><span class="RktCmt">make</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">simple</span><span class="hspace">&nbsp;</span><span class="RktCmt">part</span><span class="hspace">&nbsp;</span><span class="RktCmt">around</span><span class="hspace">&nbsp;</span><span class="RktCmt">it:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">extrude</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">difference</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">rect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bolt-pattern</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>If this were a Racket module, any code written at the top level (outside of a
<span class="RktSym">define</span> or certain other forms that postpone execution) would be
evaluated the instant this module were <span class="RktSym">require</span>-d by another.  Ruckus
rewrites the module into the following Racket code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=index.html&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktSym">racket</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">This</span><span class="hspace">&nbsp;</span><span class="RktCmt">require</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">implicitly</span><span class="hspace">&nbsp;</span><span class="RktCmt">inserted</span><span class="hspace">&nbsp;</span><span class="RktCmt">into</span><span class="hspace">&nbsp;</span><span class="RktCmt">any</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ruckus-language</span><span class="hspace">&nbsp;</span><span class="RktCmt">file.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">require</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ruckus</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">25.4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-diameter</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4.5</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bolt-pattern</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">half-sp</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">/</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">.</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">for*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">-1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">y</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">-1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">at</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">half-sp</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">half-sp</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">circle</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">#:diameter</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-diameter</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">provide</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-pattern</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Top-level</span><span class="hspace">&nbsp;</span><span class="RktCmt">geometry</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">wrapped</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">function.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Note:</span><span class="hspace">&nbsp;</span><span class="RktCmt">magical-generated-name</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">not</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">actual</span><span class="hspace">&nbsp;</span><span class="RktCmt">name</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">this</span><span class="hspace">&nbsp;</span><span class="RktCmt">function.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">It's</span><span class="hspace">&nbsp;</span><span class="RktCmt">actually</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">name</span><span class="hspace">&nbsp;</span><span class="RktCmt">generated</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">be</span><span class="hspace">&nbsp;</span><span class="RktCmt">unique.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">magical-generated-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">extrude</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">difference</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">rect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">bolt-spacing</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bolt-pattern</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">The</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">exported</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">submodule,</span><span class="hspace">&nbsp;</span><span class="RktCmt">under</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">known</span><span class="hspace">&nbsp;</span><span class="RktCmt">name,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">so</span><span class="hspace">&nbsp;</span><span class="RktCmt">that</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ruckus</span><span class="hspace">&nbsp;</span><span class="RktCmt">tools</span><span class="hspace">&nbsp;</span><span class="RktCmt">can</span><span class="hspace">&nbsp;</span><span class="RktCmt">find</span><span class="hspace">&nbsp;</span><span class="RktCmt">it.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">module*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ruckus-metadata</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">provide</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">top-level-thunk</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">top-level-thunk</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">magical-generated-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We can infer a couple of things from this example.</p><p>First, the name <span class="RktSym">ruckus-metadata</span> must not be used in a design, because
the Ruckus design language rewrite rules are going to produce a submodule with
that name.</p><p>Second, we don&rsquo;t actually have to write designs using the Ruckus design
language.  We can write them in Racket, or Typed Racket, or standard Scheme,
or any other language supported by the Racket tools.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Using_Another_Racket_Language&quot;">5.2.1.2<tt>&nbsp;</tt><a name="(part._.Using_.Another_.Racket_.Language)"></a>Using Another Racket Language</h5><p>Here&rsquo;s a design written in the core Racket language instead of the Ruckus
design language.  You can work in whichever language you prefer, but you&rsquo;ll
have to manually perform the rewrite described above.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=index.html&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktSym">racket</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Must</span><span class="hspace">&nbsp;</span><span class="RktCmt">import</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ruckus</span><span class="hspace">&nbsp;</span><span class="RktCmt">facilities</span><span class="hspace">&nbsp;</span><span class="RktCmt">manually.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">require</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ruckus</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Wrap</span><span class="hspace">&nbsp;</span><span class="RktCmt">our</span><span class="hspace">&nbsp;</span><span class="RktCmt">top-level</span><span class="hspace">&nbsp;</span><span class="RktCmt">assembly</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">function.</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">Name</span><span class="hspace">&nbsp;</span><span class="RktCmt">doesn't</span><span class="hspace">&nbsp;</span><span class="RktCmt">matter.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assembly</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ruckus</span><span class="hspace">&nbsp;</span><span class="RktCmt">language</span><span class="hspace">&nbsp;</span><span class="RktCmt">forms</span><span class="hspace">&nbsp;</span><span class="RktCmt">are</span><span class="hspace">&nbsp;</span><span class="RktCmt">available</span><span class="hspace">&nbsp;</span><span class="RktCmt">after</span><span class="hspace">&nbsp;</span><span class="RktCmt">(require</span><span class="hspace">&nbsp;</span><span class="RktCmt">ruckus)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sphere</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">300</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Expose</span><span class="hspace">&nbsp;</span><span class="RktCmt">this</span><span class="hspace">&nbsp;</span><span class="RktCmt">as</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ruckus</span><span class="hspace">&nbsp;</span><span class="RktCmt">design</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">Ruckus</span><span class="hspace">&nbsp;</span><span class="RktCmt">tools.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">module*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ruckus-metadata</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">provide</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">top-level-thunk</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">top-level-thunk</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">assembly</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Building_the_AST&quot;">5.2.2<tt>&nbsp;</tt><a name="(part._.Building_the_.A.S.T)"></a>Building the AST</h5><p>Ruckus designs are Racket code, not data structures.  This means that a
geometric construct like</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">sphere</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">100</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>is not simply a datum, but a syntactic form that can be evaluated to produce a
result.  But what result?  Ruckus designs don&rsquo;t record the value of geometric
forms like <span class="RktSym">sphere</span>, but clearly they are having an effect.</p><p>Ruckus&rsquo;s design language forms are side-effecting.  Evaluating a form like
<span class="RktSym">sphere</span> attaches information about the requested geometry to a
behind-the-scenes data structure known as the <span style="font-style: italic">EDSL stack</span>.</p><p>As these forms are evaluated, they build up an <span style="font-style: italic">abstract syntax tree</span> or
AST structure.  This is a data structure that describes a part or assembly at
roughly the same level of abstraction as a design module: primitives like
spheres and combinators like union are represented explicitly at this level.</p><p>Because of the behind-the-scenes support for Ruckus forms, you will encounter an
error if you try to evaluate one in some arbitrary context, like the Racket
REPL.  Ruckus provides the <span class="RktSym">call-with-edsl-root</span> function to evaluate
some geometry and return the AST.  Details below.</p><p>You can also view the AST for a given design file using the
<span class="stt">ruckus-dump-ast</span> tool.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_AST_Node_Structure&quot;">5.2.2.1<tt>&nbsp;</tt><a name="(part._.The_.A.S.T_.Node_.Structure)"></a><a name="(mod-path._ruckus/core/model)"></a>The AST Node Structure</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Fcore%2Fmodel%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/core/model</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=define-struct.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._struct%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">struct</a></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._ruckus/core/model..rkt)._node-children))"></a><a name="(def._((lib._ruckus/core/model..rkt)._node-atts))"></a><a name="(def._((lib._ruckus/core/model..rkt)._node-type))"></a><a name="(def._((lib._ruckus/core/model..rkt)._make-node))"></a><a name="(def._((lib._ruckus/core/model..rkt)._node~3f))"></a><a name="(def._((lib._ruckus/core/model..rkt)._struct~3anode))"></a><a name="(def._((lib._ruckus/core/model..rkt)._node))"></a><span title="Provided from: ruckus/core/model | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">node</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type</span><span class="stt"> </span><span class="RktSym">atts</span><span class="stt"> </span><span class="RktSym">children</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-node</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">type</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">symbol?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">atts</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">dict?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">children</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">node?</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">An n-way tree structure used to represent the Ruckus AST.</div></p><ul><li><p><span class="RktSym">node-type</span>: a symbol indicating the type of node, such as
<span class="RktVal">'</span><span class="RktVal">sphere</span> or <span class="RktVal">'</span><span class="RktVal">union</span>.</p></li><li><p><span class="RktSym">node-atts</span>: a collection of attributes for the node, keyed by
symbol.  Currently this is always an association list, but anything
conforming to the <span class="RktSym">dict</span> protocol will work.</p></li><li><p><span class="RktSym">node-children</span>: a list of child nodes, which may be empty for
nodes (like <span class="RktSym">sphere</span>) that have no children.</p></li><li><p><span class="RktSym">node-id</span>: a unique identifier filled in during the rewrite
pass (below).</p></li><li><p><span class="RktSym">node-color</span>: a color assigned by the <span class="RktSym">color</span> form,
or <span class="RktVal">#f</span> for the default.</p></li></ul><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_EDSL_Evaluator&quot;">5.2.2.2<tt>&nbsp;</tt><a name="(part._.The_.E.D.S.L_.Evaluator)"></a><a name="(mod-path._ruckus/lang/evaluator)"></a>The EDSL Evaluator</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Flang%2Fevaluator%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/lang/evaluator</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/lang/evaluator..rkt)._call-with-edsl-root))"></a><span title="Provided from: ruckus/lang/evaluator | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">call-with-edsl-root</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">p</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">procedure?</span></td></tr></table></blockquote></div><div class="SIntrapara">Sets up the EDSL stack and geometry environment for a new design, then calls
<span class="RktVar">p</span> with no arguments.</div></p><p>Returns the <span class="RktSym">node</span> that results from evaluating any Ruckus design
language forms inside <span class="RktVar">p</span>.  If there are no such forms, the result is
an empty node.</p><p><span class="RktSym">call-with-edsl-root</span> is mostly useful if you are implementing tools
that interact directly with Ruckus designs, or want to experiment with Ruckus
design language forms in the REPL:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">ruckus</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">sphere</span><span class="hspace">&nbsp;</span><span class="RktVal">100</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">first: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: (and/c list? (not/c empty?))</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: '()</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">ruckus/lang/evaluator</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">call-with-edsl-root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sphere</span><span class="hspace">&nbsp;</span><span class="RktVal">100</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(node <span class="stt"> </span>'root<span class="stt"> </span>'()<span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>(list <span class="stt"> </span>(node <span class="stt"> </span>'sphere<span class="stt"> </span>'((radius<span class="stt"> </span>. 100))<span class="stt"> </span>'())))</span></p></td></tr></table></blockquote><p>The result of <span class="RktSym">call-with-edsl-root</span> is always of <span class="RktSym">node-type</span>
<span class="RktVal">'</span><span class="RktVal">root</span>, and is <span style="font-style: italic">non-canonical</span>.  To fix this, apply
<span class="RktSym">canonicalize</span>.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;AST_Rewriting&quot;">5.2.3<tt>&nbsp;</tt><a name="(part._.A.S.T_.Rewriting)"></a>AST Rewriting</h5><p>The AST rewrite pass is responsible for <span style="font-style: italic">canonicalizing</span> the AST and
<span style="font-style: italic">enumerating</span> the leaf nodes.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Canonicalization&quot;">5.2.3.1<tt>&nbsp;</tt><a name="(part._.Canonicalization)"></a><a name="(mod-path._ruckus/core/compiler/canon)"></a>Canonicalization</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Fcore%2Fcompiler%2Fcanon%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/core/compiler/canon</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/core/compiler/canon..rkt)._canonicalize))"></a><span title="Provided from: ruckus/core/compiler/canon | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">canonicalize</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">node?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Canonicalizes a node.  In general, the process involves:</div></p><ul><li><p>Rewriting <span class="RktVal">'</span><span class="RktVal">root</span> nodes into <span class="RktVal">'</span><span class="RktVal">union</span>.</p></li><li><p>Converting nodes with many children into binary trees.</p></li><li><p>Flattening combinators with a single child node.</p></li><li><p>Combining nested transforms that can be combined (e.g. nested
<span class="RktSym">at</span> forms).</p></li><li><p>Identifying and removing do-nothing transforms (e.g. translation by
zero).</p></li></ul><p>The result of <span class="RktSym">canonicalize</span> may be:</p><ul><li><p>Zero nodes, if the node contents were completely eliminated by
flattening and combining,</p></li><li><p>One node, or</p></li><li><p>Many nodes, if <span class="RktVar">n</span> represented a do-nothing transform with
several children.</p></li></ul><p>If <span class="RktVar">n</span> is known to be a <span class="RktVal">'</span><span class="RktVal">root</span> node, of the form returned from
<span class="RktSym">call-with-edsl-root</span>, then the "many nodes" case won&rsquo;t happen.</p><p>You can view the result of canonicalization on a design using
<span class="stt">ruckus-dump-ast -c</span>.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Enumeration&quot;">5.2.3.2<tt>&nbsp;</tt><a name="(part._.Enumeration)"></a><a name="(mod-path._ruckus/core/compiler/enumerate)"></a>Enumeration</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left" colspan="2"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Fcore%2Fcompiler%2Fenumerate%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/core/compiler/enumerate</span></a><span class="RktPn">)</span></td></tr><tr><td align="left">&nbsp;</td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._ruckus/core/compiler/enumerate..rkt)._enumerate-nodes))"></a><span title="Provided from: ruckus/core/compiler/enumerate | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">enumerate-nodes</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">next-id</span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><table cellspacing="0" cellpadding="0"><tr><td><span class="RktSym">integer?</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym">node?</span></td></tr></table></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">next-id</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Recursively enumerates nodes in <span class="RktVar">n</span>, returning a <span class="RktSym">node</span> of the
same shape, but wherein every node has either children or a unique
<span class="RktSym">node-id</span>.</div></p><p>This is used in later phases that need to discriminate between different parts
of a surface, e.g. to change colors or material properties.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Lowering_to_Ruckus_IR&quot;">5.2.4<tt>&nbsp;</tt><a name="(part._.Lowering_to_.Ruckus_.I.R)"></a><a name="(mod-path._ruckus/core/compiler/lower)"></a>Lowering to Ruckus IR</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Fcore%2Fcompiler%2Flower%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/core/compiler/lower</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p>After the AST is canonicalized and enumerated, we <span style="font-style: italic">lower</span> it to a
different form: the Ruckus Intermediate Representation, or IR.  This breaks down
complex operations like <span class="RktSym">smooth-union</span> or <span class="RktSym">radial-repeat</span> into
graphs of more primitive operations.  As a result, it loses most of the
high-level structural information present in the AST, but makes it much easier
to perform target-specific code generation and optimization.</p><p>The Ruckus IR is a static single assignment code for describing branchless
arithmetic trees as value flow graphs.  IR programs are pure and the evaluation
semantics (e.g. eager, lazy) are not specified.  IR code looks vaguely like an
assembly language represented using s-expressions with an infinite register set.</p><p>The goal of an IR program is to simultaneously evaluate the Lipschitz-continuous
signed distance bound field, and to produce the <span class="RktSym">node-id</span> of the nearest
surface.  Value ("register") zero contains the "query point," the point in
3-space where the field is being evaluated.</p><p>You can view the IR for a design using the <span class="stt">ruckus-dump-ir</span> tool.  Here is
a design and its IR; the sections below will go into more detail about what this
means.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="Ruckus_Language_Reference.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">difference</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">at</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cube</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">170</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sphere</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">100</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assign3f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sub</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">c3f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">#(</span><span class="RktMeta">struct:vec3</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">box</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">c3f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">#(</span><span class="RktMeta">struct:vec3</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">85</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">85</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">85</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignu</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cu</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sphere</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">100</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignu</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cu</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sub</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">max</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assignu</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">8</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">choose</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">r</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Signed</span><span class="hspace">&nbsp;</span><span class="RktCmt">distance</span><span class="hspace">&nbsp;</span><span class="RktCmt">bound</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">value</span><span class="hspace">&nbsp;</span><span class="RktCmt">7</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Dominating</span><span class="hspace">&nbsp;</span><span class="RktCmt">node</span><span class="hspace">&nbsp;</span><span class="RktCmt">ID</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">value</span><span class="hspace">&nbsp;</span><span class="RktCmt">8</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/core/compiler/lower..rkt)._generate-statements))"></a><span title="Provided from: ruckus/core/compiler/lower | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">generate-statements</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Generates Ruckus IR assignments implementing <span class="RktVar">n</span>.  Internally
canonicalizes and enumerates <span class="RktVar">n</span>, so you don&rsquo;t need to.</div></p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Assignments&quot;">5.2.4.1<tt>&nbsp;</tt><a name="(part._.Assignments)"></a>Assignments</h5><p>An IR program consists of a list of <span style="font-style: italic">value assignments</span>.  Each assignment
defines a new register (by number) whose value is the content of a particular
expression.  The general form is:</p><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">assign-type</span><span class="stt"> </span><span class="RktVal">register-number</span><span class="stt"> </span><span class="RktVal">expression</span><span class="RktVal">)</span></p><ul><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">assignf</span><span class="stt"> </span><span class="RktVal">r</span><span class="stt"> </span><span class="RktVal">e</span><span class="RktVal">)</span> evaluates <span class="RktSym">e</span> for a floating point
result, which gets stored in register number <span class="RktSym">r</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">assignu</span><span class="stt"> </span><span class="RktVal">r</span><span class="stt"> </span><span class="RktVal">e</span><span class="RktVal">)</span> evaluates <span class="RktSym">e</span> for an unsigned integer
result, which gets stored in register number <span class="RktSym">r</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">assign3f</span><span class="stt"> </span><span class="RktVal">r</span><span class="stt"> </span><span class="RktVal">e</span><span class="RktVal">)</span> evaluates <span class="RktSym">e</span> for an 3-vector floating
point result, which gets stored in register number <span class="RktSym">r</span>.</p></li></ul><p>It&rsquo;s an error if a single Ruckus IR sequence contains two assignments to the
same register number.  Because register zero is predefined, an IR program should
also not contain an assignment to register zero.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Expressions&quot;">5.2.4.2<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h5><p>Expressions have a form similar to Racket expressions: they are lists with the
function first and some number of arguments after that:</p><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">operation-type</span><span class="stt"> </span><span class="RktVal">arg1</span><span class="stt"> </span><span class="RktVal">arg2</span><span class="stt"> </span><span class="RktVal">...</span><span class="RktVal">)</span></p><p>For a precise list of operation types permitted, see
<a href="#%28mod-path._ruckus%2Fcore%2Fcompiler%2Fracket%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/core/compiler/racket</span></a>.  Here are some examples for
illustrative purposes:</p><ul><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">r</span><span class="stt"> </span><span class="RktVal">n</span><span class="RktVal">)</span> is the value in register <span class="RktSym">n</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">cf</span><span class="stt"> </span><span class="RktVal">x</span><span class="RktVal">)</span> is a floating point constant with value <span class="RktSym">x</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">cf3</span><span class="stt"> </span><span class="RktVal">x</span><span class="stt"> </span><span class="RktVal">y</span><span class="stt"> </span><span class="RktVal">z</span><span class="RktVal">)</span> is a 3-vector floating point constant.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">add</span><span class="stt"> </span><span class="RktVal">dim</span><span class="stt"> </span><span class="RktVal">a</span><span class="stt"> </span><span class="RktVal">b</span><span class="RktVal">)</span> adds the result of two expressions <span class="RktSym">a</span>
and <span class="RktSym">b</span>, which must have dimension <span class="RktSym">dim</span> (e.g. 1 for
scalar, 3 for e-vector, etc.).  The result has the same dimension.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">choose</span><span class="stt"> </span><span class="RktVal">flag</span><span class="stt"> </span><span class="RktVal">a</span><span class="stt"> </span><span class="RktVal">b</span><span class="RktVal">)</span> is equivalent to Racket <span class="RktSym">if</span> or C&rsquo;s
ternary operator: depending on the value of expression <span class="RktSym">flag</span>,
the <span class="RktSym">choose</span> expression evaluates to one of the expressions
<span class="RktSym">a</span> (if true) or <span class="RktSym">b</span> (if false).</p></li></ul><p>Unlike most assembly languages, expressions in Ruckus IR can be arbitrarily
nested.  The following is a valid assigment in Ruckus IR:</p><p><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">assignf</span><span class="stt"> </span><span class="RktVal">10</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">add</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">r</span><span class="stt"> </span><span class="RktVal">6</span><span class="RktVal">)</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">mul</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">cf</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktVal">)</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">r</span><span class="stt"> </span><span class="RktVal">7</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></p><p>That&rsquo;s essentially equivalent to the Racket code</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">r6</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">r7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">r10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">r6</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">r7</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Value_Pruning&quot;">5.2.4.3<tt>&nbsp;</tt><a name="(part._.Value_.Pruning)"></a>Value Pruning</h5><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/core/compiler/lower..rkt)._prune-statements))"></a><span title="Provided from: ruckus/core/compiler/lower | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">prune-statements</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">statements</span><span class="hspace">&nbsp;</span><span class="RktVar">result</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">statements</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">list?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">result</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">integer?</span></td></tr></table></blockquote></div><div class="SIntrapara">Given a list of <span class="RktVar">statements</span>, of the sort produced by
<span class="RktSym">generate-statements</span>, returns a similar list containing only those
assignments that contribute to the production of the numbered value
<span class="RktVar">result</span>.</div></p><p>Because the default IR programs compute two different things simultaneously
&#8212;<wbr></wbr> the signed distance bound field and the dominating node ID &#8212;<wbr></wbr> backends
use <span class="RktSym">prune-statements</span> to optimize if only one or the other is
required.</p><p>Note that, in general, computing the dominating node ID is more expensive than
computing the distance field bound, even after pruning.</p><p>You can see the result of pruning on a design by passing the <span class="stt">-p</span> switch
to the <span class="stt">ruckus-dump-ir</span> tool.</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;Target_Backends&quot;">5.2.5<tt>&nbsp;</tt><a name="(part._.Target_.Backends)"></a>Target Backends</h5><p>Ruckus does not interpret or execute Ruckus IR programs directly.  The target
backends are responsible for transforming Ruckus IR code into some form of
executable code.</p><p>There are currently two backends implemented, one that generates Racket, and one
that generates the OpenGL Shader Language (GLSL).</p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_Racket_Backend&quot;">5.2.5.1<tt>&nbsp;</tt><a name="(part._.The_.Racket_.Backend)"></a><a name="(mod-path._ruckus/core/compiler/racket)"></a>The Racket Backend</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Fcore%2Fcompiler%2Fracket%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/core/compiler/racket</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p>The Racket backend is the simplest backend, and the first one to read if you&rsquo;re
curious.  It converts nodes into functions (going through IR internally).</p><p>The functions returned in both cases are produced by <span class="RktSym">eval</span>, not
interpreted at the IR level.</p><p>The backend works by recursively rewriting IR expressions into equivalent Racket
expressions, and using <span class="RktSym">let</span> forms to declare Racket variables
corresponding to IR values.  (Value number 12 produces a variable named
<span class="stt">r12</span>.)</p><p>You can view the Racket code corresponding to a design using the
<span class="stt">ruckus-dump-rkt</span> tool.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/core/compiler/racket..rkt)._node-~3edistance-function))"></a><span title="Provided from: ruckus/core/compiler/racket | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">node-&gt;distance-function</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">vec3?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">real?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Converts <span class="RktVar">n</span> into a Racket function that evaluates the design&rsquo;s signed
distance bound function.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/core/compiler/racket..rkt)._node-~3ediscriminator))"></a><span title="Provided from: ruckus/core/compiler/racket | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">node-&gt;discriminator</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">vec3?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">integer?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Converts <span class="RktVar">n</span> into a Racket function that finds the node ID of the
nearest surface to a given point.</div></p><h5 x-source-module="(lib &quot;ruckus/doc/ruckus.scrbl&quot;)" x-source-pkg="ruckus" x-part-tag="&quot;The_GLSL_Backend&quot;">5.2.5.2<tt>&nbsp;</tt><a name="(part._.The_.G.L.S.L_.Backend)"></a><a name="(mod-path._ruckus/viz/glsl)"></a>The GLSL Backend</h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=8.6" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="#%28mod-path._ruckus%2Fviz%2Fglsl%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">ruckus/viz/glsl</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/ruckus" title="Install this package using `raco pkg install ruckus`"><span class="stt">ruckus</span></a></span></td></tr></table></p><p>The GLSL backend is more complicated than the Racket backend, because GLSL is a
C-style braces-and-semicolons language with explicit type declarations.  (It&rsquo;s
still only about 100 lines of code.)</p><p>You can view the GLSL code corresponding to a design using the
<span class="stt">ruckus-dump-glsl</span> tool.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/viz/glsl..rkt)._node-~3eglsl-distance))"></a><span title="Provided from: ruckus/viz/glsl | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">node-&gt;glsl-distance</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">string?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Converts <span class="RktVar">n</span> into the text of a GLSL function that evaluates the
design&rsquo;s signed distance bound function.  The result contains one string per
line.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._ruckus/viz/glsl..rkt)._node-~3eglsl-disc))"></a><span title="Provided from: ruckus/viz/glsl | Package: ruckus"><span class="RktSym"><span class="RktSymDef RktSym">node-&gt;glsl-disc</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">string?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">node?</span></td></tr></table></blockquote></div><div class="SIntrapara">Converts <span class="RktVar">n</span> into the text of a GLSL function that finds the node ID of
the nearest surface to a given point.  The result contains one string per
line.</div></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.6&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="The_Ruckus_Tools.html" title="backward to &quot;4 The Ruckus Tools&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Ruckus: Procedural CAD For Weirdos&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body>
<!-- Mirrored from docs.racket-lang.org/ruckus/Internals.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 07 Sep 2022 03:30:43 GMT -->
</html>