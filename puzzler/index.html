<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Mirrored from docs.racket-lang.org/puzzler/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 07 Sep 2022 03:04:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Puzzler: A Language for 2D Puzzle Game Creation</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="#" class="tocviewselflink" data-pltdoc="x">Puzzler:<span class="mywbr"> &nbsp;</span> A Language for 2D Puzzle Game Creation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._sokoban%29" class="tocviewlink" data-pltdoc="x">An Example:<span class="mywbr"> &nbsp;</span> Sokoban</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._maps%29" class="tocviewlink" data-pltdoc="x">Maps</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Drawing_and_.Images%29" class="tocviewlink" data-pltdoc="x">Drawing and Images</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Actions%29" class="tocviewlink" data-pltdoc="x">Actions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Interactions_and_.Events%29" class="tocviewlink" data-pltdoc="x">Interactions and Events</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Winning_and_.Losing%29" class="tocviewlink" data-pltdoc="x">Winning and Losing</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Conclusion_and_.Future_.Work%29" class="tocviewlink" data-pltdoc="x">Conclusion and Future Work</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._top%29" class="tocsubseclink" data-pltdoc="x">Puzzler:<span class="mywbr"> &nbsp;</span> A Language for 2D Puzzle Game Creation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._sokoban%29" class="tocsubseclink" data-pltdoc="x">An Example:<span class="mywbr"> &nbsp;</span> Sokoban</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Map_.Section%29" class="tocsubseclink" data-pltdoc="x">The Map Section</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Goal_.Map_.Section%29" class="tocsubseclink" data-pltdoc="x">The Goal Map Section</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Draw_.Section%29" class="tocsubseclink" data-pltdoc="x">The Draw Section</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._.The_.Action_.Section%29" class="tocsubseclink" data-pltdoc="x">The Action Section</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._.The_.Interaction_.Section%29" class="tocsubseclink" data-pltdoc="x">The Interaction Section</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#%28part._.Wrapping_.Up__.A_.Finished_.Game%29" class="tocsubseclink" data-pltdoc="x">Wrapping Up:<span class="mywbr"> &nbsp;</span> A Finished Game</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._maps%29" class="tocsubseclink" data-pltdoc="x">Maps</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Basic_.Map_.Rules%29" class="tocsubseclink" data-pltdoc="x">Basic Map Rules</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Multiple_.Maps%29" class="tocsubseclink" data-pltdoc="x">Multiple Maps</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Drawing_and_.Images%29" class="tocsubseclink" data-pltdoc="x">Drawing and Images</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Draw_.Rules%29" class="tocsubseclink" data-pltdoc="x">Draw Rules</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Built-.Ins%29" class="tocsubseclink" data-pltdoc="x">Built-<wbr></wbr>Ins</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Actions%29" class="tocsubseclink" data-pltdoc="x">Actions</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Action_.Rules%29" class="tocsubseclink" data-pltdoc="x">Action Rules</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Interactions_and_.Events%29" class="tocsubseclink" data-pltdoc="x">Interactions and Events</a></td></tr><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.Interaction_.Rules%29" class="tocsubseclink" data-pltdoc="x">Interaction Rules</a></td></tr><tr><td><span class="tocsublinknumber">5.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Conflicting_.Interactions%29" class="tocsubseclink" data-pltdoc="x">Conflicting Interactions</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Events__.Well__just_.Event_.Really_%29" class="tocsubseclink" data-pltdoc="x">Events (Well, just Event Really)</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Winning_and_.Losing%29" class="tocsubseclink" data-pltdoc="x">Winning and Losing</a></td></tr><tr><td><span class="tocsublinknumber">6.1<tt>&nbsp;</tt></span><a href="#%28part._.Defining_.Win_.Conditions%29" class="tocsubseclink" data-pltdoc="x">Defining Win Conditions</a></td></tr><tr><td><span class="tocsublinknumber">6.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Goal_.Maps%29" class="tocsubseclink" data-pltdoc="x">Goal Maps</a></td></tr><tr><td><span class="tocsublinknumber">6.2<tt>&nbsp;</tt></span><a href="#%28part._.Defining_.Lose_.Conditions%29" class="tocsubseclink" data-pltdoc="x">Defining Lose Conditions</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Conclusion_and_.Future_.Work%29" class="tocsubseclink" data-pltdoc="x">Conclusion and Future Work</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.6</span></div><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.6&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h2 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;top&quot;"><a name="(part._top)"></a><a name="(part._.Puzzler__.A_.Language_for_2.D_.Puzzle_.Game_.Creation)"></a><a name="(mod-path._puzzler)"></a>Puzzler: A Language for 2D Puzzle Game Creation</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Alex Owens</p></span></div><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="hspace">&nbsp;</span><a href="#" class="RktModLink" data-pltdoc="x"><span class="RktSym">puzzler</span></a></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/puzzler" title="Install this package using `raco pkg install puzzler`"><span class="stt">puzzler</span></a></span></td></tr></table></p><p>Puzzler is a DSL designed to streamline the creation of 2D puzzle games. In general, Puzzler allows its users to express simple grid-based puzzle games in a succinct and declarative way.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sokoban%29" class="toptoclink" data-pltdoc="x">1<span class="hspace">&nbsp;</span>An Example: Sokoban</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Map_.Section%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>The Map Section</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Goal_.Map_.Section%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>The Goal Map Section</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Draw_.Section%29" class="toclink" data-pltdoc="x">1.3<span class="hspace">&nbsp;</span>The Draw Section</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Action_.Section%29" class="toclink" data-pltdoc="x">1.4<span class="hspace">&nbsp;</span>The Action Section</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Interaction_.Section%29" class="toclink" data-pltdoc="x">1.5<span class="hspace">&nbsp;</span>The Interaction Section</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Wrapping_.Up__.A_.Finished_.Game%29" class="toclink" data-pltdoc="x">1.6<span class="hspace">&nbsp;</span>Wrapping Up: A Finished Game</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._maps%29" class="toptoclink" data-pltdoc="x">2<span class="hspace">&nbsp;</span>Maps</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Basic_.Map_.Rules%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Basic Map Rules</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Multiple_.Maps%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Multiple Maps</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Drawing_and_.Images%29" class="toptoclink" data-pltdoc="x">3<span class="hspace">&nbsp;</span>Drawing and Images</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Draw_.Rules%29" class="toclink" data-pltdoc="x">3.1<span class="hspace">&nbsp;</span>Draw Rules</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Built-.Ins%29" class="toclink" data-pltdoc="x">3.2<span class="hspace">&nbsp;</span>Built-Ins</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Actions%29" class="toptoclink" data-pltdoc="x">4<span class="hspace">&nbsp;</span>Actions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Action_.Rules%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>Action Rules</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Interactions_and_.Events%29" class="toptoclink" data-pltdoc="x">5<span class="hspace">&nbsp;</span>Interactions and Events</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Interaction_.Rules%29" class="toclink" data-pltdoc="x">5.1<span class="hspace">&nbsp;</span>Interaction Rules</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Conflicting_.Interactions%29" class="toclink" data-pltdoc="x">5.1.1<span class="hspace">&nbsp;</span>Conflicting Interactions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Events__.Well__just_.Event_.Really_%29" class="toclink" data-pltdoc="x">5.2<span class="hspace">&nbsp;</span>Events (Well, just Event Really)</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Winning_and_.Losing%29" class="toptoclink" data-pltdoc="x">6<span class="hspace">&nbsp;</span>Winning and Losing</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Defining_.Win_.Conditions%29" class="toclink" data-pltdoc="x">6.1<span class="hspace">&nbsp;</span>Defining Win Conditions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Goal_.Maps%29" class="toclink" data-pltdoc="x">6.1.1<span class="hspace">&nbsp;</span>Goal Maps</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Defining_.Lose_.Conditions%29" class="toclink" data-pltdoc="x">6.2<span class="hspace">&nbsp;</span>Defining Lose Conditions</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Conclusion_and_.Future_.Work%29" class="toptoclink" data-pltdoc="x">7<span class="hspace">&nbsp;</span>Conclusion and Future Work</a></p></td></tr></table><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;sokoban&quot;">1<tt>&nbsp;</tt><a name="(part._sokoban)"></a>An Example: Sokoban</h3><p>A Puzzler program generates a <span class="RktSym">racket/gui</span> program based on various <span style="font-style: italic">sections</span> specified by its author. In this example, we will be looking at a game built with Puzzler
called "Sokoban". <a href="https://en.wikipedia.org/wiki/Sokoban">Sokoban</a> is a puzzle game in which the player must push boxes into specific locations on the map without blocking themselves or other boxes in and thus making the puzzle
impossible to solve. It was originally released in 1982, but has spawned numerous derivatives and varieties.</p><p>A screenshot of this game running on Puzzler (with my excellent programmer art) is below:</p><blockquote class="SCentered"><p><img src="sokoban.png" alt="" width="510" height="526"/></p></blockquote><blockquote class="SCentered"><p>Sokoban Game</p></blockquote><p>And the source code for this game in Puzzler is as follows:</p><blockquote class="SCentered"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><a href="https://download.racket-lang.org/releases/8.6/doc/local-redirect/index.html?doc=guide&amp;rel=Module_Syntax.html%23%2528part._hash-lang%2529&amp;version=8.6" class="RktModLink Sq" data-pltdoc="x"><span class="RktMod">#lang</span></a><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><a href="#" class="RktModLink" data-pltdoc="x"><span class="RktSym">puzzler</span></a><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta">START_MAP</span></td></tr><tr><td><span class="RktMeta">P#####</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">##BBB#</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">END_MAP</span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta">START_GOAL_MAP</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">######</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">##B###</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">#B####</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">B#####</span></td></tr><tr><td><span class="RktMeta">END_GOAL_MAP</span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta">draw:</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"P"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"player.png"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"B"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"rect"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta">action:</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"P"</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"up"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">0</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"P"</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"down"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">0</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">-1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"P"</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"left"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">-1</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"P"</span><span class="RktMeta">:</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"right"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta">interactions:</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"P"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">push</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"B"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktVal">"B"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">stop</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"B"</span><span class="RktMeta"></span></td></tr></table></blockquote></blockquote><p>As you can see, Puzzler is more of a description language than a standard procedural-style programming language like you might be used to. Nevertheless,
it allows for quite a bit of expressiveness in a small package.</p><p>In the rest of this guide we will break down what makes this Sokoban example work, and how the various sections interact to generate a meaningful program.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;The_Map_Section&quot;">1.1<tt>&nbsp;</tt><a name="(part._.The_.Map_.Section)"></a>The Map Section</h4><p>All Puzzler programs begin with a <span style="font-style: italic">map section</span>. Our <span style="font-style: italic">map section</span> in Sokoban looks like this</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_MAP</span></p></td></tr><tr><td><p><span class="stt">P#####</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">##BBB#</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">END_MAP</span></p></td></tr></table></p><p>The <span style="font-style: italic">map section</span> starts with a line <span style="font-style: italic"><span style="font-weight: bold">START_MAP</span></span>, which denotes the beginning of the <span style="font-style: italic">map section</span>. Each newline following this is considered
a new row in the grid. In this example you can see the first row is "P#####". The character "#" represents an empty space in a Puzzler map, while all other character
are special entities in the game.</p><p>The "P" in this map represents the player, and similarly the "B"s represent the boxes. It is easy to track which characters map to which entities by looking in the game&rsquo;s
<span style="font-style: italic">draw section</span>, which we will cover in a bit.</p><p>The map section is closed with a line <span style="font-style: italic"><span style="font-weight: bold">END_MAP</span></span>, denoting that we are done describing the game&rsquo;s map.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;The_Goal_Map_Section&quot;">1.2<tt>&nbsp;</tt><a name="(part._.The_.Goal_.Map_.Section)"></a>The Goal Map Section</h4><p>Many games&#8212;<wbr></wbr>all games built with Puzzler&#8212;<wbr></wbr>need a win condition. One way of describing a win condition in Puzzler is with a <span style="font-style: italic">goal map section</span>.
The <span style="font-style: italic">goal map section</span> in our Sokoban game looks very similar to a normal <span style="font-style: italic">map section</span>:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_GOAL_MAP</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">##B###</span></p></td></tr><tr><td><p><span class="stt">#B####</span></p></td></tr><tr><td><p><span class="stt">B#####</span></p></td></tr><tr><td><p><span class="stt">END_GOAL_MAP</span></p></td></tr></table></p><p>The concept of a goal map is pretty simple. It essentially just says "if the map ever looks like this, then the game can be considered won". Different games may have different ways
for the map to change, but the principle of winning via a <span style="font-style: italic">goal map section</span> stays the same. For our purposes in building Sokoban, this is the same thing as saying "The player has pushed all
the boxes into their designated locations".</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;The_Draw_Section&quot;">1.3<tt>&nbsp;</tt><a name="(part._.The_.Draw_.Section)"></a>The Draw Section</h4><p>The purpose of the <span style="font-style: italic">draw section</span> is to map the game entities on a Puzzler map to their image files. This also serves as a list of all the important entities within the game.
The <span style="font-style: italic">draw section</span> consists of one or more <span style="font-style: italic">draw rule</span>s, which associate an entity to an image file. In our Sokoban example, the <span style="font-style: italic">draw section</span> looks like this:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">draw:</span></p></td></tr><tr><td><p><span class="stt">"P" -&gt; "player.png"</span></p></td></tr><tr><td><p><span class="stt">"B" -&gt; "rect"</span></p></td></tr></table></p><p>The first rule tells the Puzzler rendering system to draw the image "player.png" for every occurence of a "P" on the map. This is similar for the second rule, except that "rect" is a reserved
symbol within the context of a Puzzler draw rule. The rendering system will draw a black rectangle for every "rect" occurence in Puzzler. In Sokoban, all of the boxes("B") that the player pushes
are represented in this way.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;The_Action_Section&quot;">1.4<tt>&nbsp;</tt><a name="(part._.The_.Action_.Section)"></a>The Action Section</h4><p>So far we&rsquo;ve only seen descriptions of the static elements of our Sokoban program, but it wouldn&rsquo;t be a game without some way to interact with the program&rsquo;s state. This is where the <span style="font-style: italic">action section</span>
comes in. The <span style="font-style: italic">action section</span> describes how the player interacts with the elements in the game through input. Similar to the <span style="font-style: italic">draw section</span>, the <span style="font-style: italic">action section</span> is broken down into
<span style="font-style: italic">action rule</span>s, which describe how a given input changes the game&rsquo;s state. The <span style="font-style: italic">action section</span> in the Sokoban example is as follows:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">action:</span></p></td></tr><tr><td><p><span class="stt">"P": "up" -&gt; (0, 1)</span></p></td></tr><tr><td><p><span class="stt">"P": "down" -&gt; (0, -1)</span></p></td></tr><tr><td><p><span class="stt">"P": "left" -&gt; (-1, 0)</span></p></td></tr><tr><td><p><span class="stt">"P": "right" -&gt; (1, 0)</span></p></td></tr></table></p><p>The first rule in this example states that whenever the "up" key is pressed on the keyboard, any "P" entity (in this case the player)
will have its position changed by 0 in the X direction and 1 in the Y direction. The rest of the <span style="font-style: italic">action rule</span>s are very similar, changing only the key and the DX/DY values. In this
game there is only one "P", but if there were multiple then these actions would be applied to all of the matched entities.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;The_Interaction_Section&quot;">1.5<tt>&nbsp;</tt><a name="(part._.The_.Interaction_.Section)"></a>The Interaction Section</h4><p>With the <span style="font-style: italic">action section</span> we have seen how to let players interact with the game world, but how do entities interact with each other? These kinds of interactions are expressed via
the <span style="font-style: italic">interaction section</span>. Sticking with Puzzler tradition, this section consists of one or more <span style="font-style: italic">interaction rule</span>s. The interactions in Sokoban are expressed like this:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">interactions:</span></p></td></tr><tr><td><p><span class="stt">"P" push "B"</span></p></td></tr><tr><td><p><span class="stt">"B" stop "B"</span></p></td></tr></table></p><p>The way to read each of these rules is "When Entity1 collides with Entity2, X Interaction happens". So in the first rule, we have &rsquo;"P" push "B"&rsquo;, which means that the entity "P" will "push" the entity
"B" upon collision. The "push" interaction is something built in to Puzzler which means that the entity being acted upon&#8212;<wbr></wbr>in this case "B"&#8212;<wbr></wbr>will be moved in whatever direction the entity acting upon
it&#8212;<wbr></wbr>"P"&#8212;<wbr></wbr>is moving in. Similarly, the second rule states that when a "B" entity interacts with another "B" entity, it will be "stopped". The "stop" interaction is also built in, which essentially just
blocks movement.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Wrapping_Up__A_Finished_Game&quot;">1.6<tt>&nbsp;</tt><a name="(part._.Wrapping_.Up__.A_.Finished_.Game)"></a>Wrapping Up: A Finished Game</h4><p>As you can see, we now have all the pieces to create a working version of the game Sokoban. We can describe maps, goal maps for where to push boxes, player input and movement, sprite rendering,
and interactions between game entities. This has all been done in roughly 30 lines of Puzzler code. More importantly, we can scale this example to produce more levels, entity types, and interactions
by simply adding a few more rules. This is the purpose of the Puzzler language, and hopefully you&rsquo;ve seen that it&rsquo;s easy to express an interesting game without having to worry about too many complex
and interacting systems.</p><p>If you are looking for more information about the specifics of Puzzler, please check out the documentation for each of the different <span style="font-style: italic">sections</span>. If you&rsquo;d like to see more examples of games that
can be built with Puzzler, clone or view the source code for Puzzler <a href="https://en.wikipedia.org/wiki/Sokoban">on GitHub</a> and look in the examples directory.</p><p>Thanks for reading and have fun building puzzle games!</p><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;maps&quot;">2<tt>&nbsp;</tt><a name="(part._maps)"></a>Maps</h3><p>Every game built with Puzzler will start with a <span style="font-style: italic">map section</span>. This defines the "game world" so to speak, which is represented by
a grid of characters.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Basic_Map_Rules&quot;">2.1<tt>&nbsp;</tt><a name="(part._.Basic_.Map_.Rules)"></a>Basic Map Rules</h4><p>Puzzler maps are made up of blank spaces and entities in the following form:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_MAP</span></p></td></tr><tr><td><p><span class="stt">&lt;map_row&gt;</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr><tr><td><p><span class="stt">END_MAP</span></p></td></tr></table></p><p>Where <span style="font-style: italic">&lt;map_row&gt;</span> is a visual representation of a row on the grid, such as "###" or "#P#". Each <span style="font-style: italic">&lt;map_row&gt;</span> is separated by a new line.
In Puzzler, a "#" character on the map means empty space, and any other character represents an entity in the game. For example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_MAP</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt">##P##</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt">END_MAP</span></p></td></tr></table></p><p>The above map is a 5x3 grid with some entity "P" (by convention we make the player "P", but it could be anything) in the center of 2nd row. This
example illustrates an important example about Puzzler maps in that <span style="font-weight: bold">they do not have to be square</span>. We could have a 5x3, 5x5, 3x5, or even
a 1x1 (although that wouldn&rsquo;t be very interesting). It is important, however, to note that <span style="font-weight: bold">all rows must be the same length</span>. We cannot
do something like the following:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_MAP</span></p></td></tr><tr><td><p><span class="stt">##P##</span></p></td></tr><tr><td><p><span class="stt">####</span></p></td></tr><tr><td><p><span class="stt">###</span></p></td></tr><tr><td><p><span class="stt">END_MAP</span></p></td></tr></table></p><p>This would fail to build in Puzzler, as we are currently limited to making all Puzzler maps rectangular.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Multiple_Maps&quot;">2.2<tt>&nbsp;</tt><a name="(part._.Multiple_.Maps)"></a>Multiple Maps</h4><p>You can build games in Puzzler which have multiple levels, and the syntax is pretty simple, for example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_MAP</span></p></td></tr><tr><td><p><span class="stt">P####</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt">##P##</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt">#####</span></p></td></tr><tr><td><p><span class="stt">####P</span></p></td></tr><tr><td><p><span class="stt">END_MAP</span></p></td></tr></table></p><p>The above map section generates a Puzzler game with 3 levels which progress in the order that they are defined. While <span style="font-style: italic">map_row</span>s are separated by newlines, maps are separated by a
blank line. Puzzler will continue to look for maps until it sees the <span style="font-style: italic"><span style="font-weight: bold">END_MAP</span></span> token. Games with multiple map definitions have the same rules as games with only one map, however,
it is important to know that <span style="font-weight: bold">all maps must be the same size</span>.</p><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Drawing_and_Images&quot;">3<tt>&nbsp;</tt><a name="(part._.Drawing_and_.Images)"></a>Drawing and Images</h3><p>Every game you build with Puzzler will have some images which represent entities in the game. In our <a href="#%28part._sokoban%29" data-pltdoc="x">Sokoban game</a>, for example, we had an image for
the player as well as an image for the boxes the player pushes around. Managing which images map to which game entities is the responsibility of our game&rsquo;s
<span style="font-style: italic">draw section</span>.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Draw_Rules&quot;">3.1<tt>&nbsp;</tt><a name="(part._.Draw_.Rules)"></a>Draw Rules</h4><p>The Puzzler draw section looks like this:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">draw:</span></p></td></tr><tr><td><p><span class="stt">&lt;draw_rule&gt;</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p>Where <span style="font-style: italic">&lt;draw_rule&gt;</span> is of the form <span style="font-style: italic">"&lt;entity_character&gt;" -&gt; "&lt;image_path&gt;"</span>. Remember that in Puzzler every game entity is represented on the map as a single character like
"P" or "X". So, for example, if we wanted to draw some image <span style="font-style: italic">"player.png"</span> for our game entity "P", we would do the following:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">draw:</span></p></td></tr><tr><td><p><span class="stt">"P" -&gt; "player.png"</span></p></td></tr></table></p><p>This can be read as something like "P draws player.png". It is important to remember that <span style="font-weight: bold">image paths are defined in relation to where the Puzzler game is executing</span>.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Built-Ins&quot;">3.2<tt>&nbsp;</tt><a name="(part._.Built-.Ins)"></a>Built-Ins</h4><p>There is one special case of draw rules in Puzzler: the reserved word <span style="font-style: italic">"rect"</span>. Any entity which maps to "rect" in a draw rule will be drawn as a black box
the same size as a single grid square. In the Sokoban example we had:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">draw:</span></p></td></tr><tr><td><p><span class="stt">"P" -&gt; "player.png"</span></p></td></tr><tr><td><p><span class="stt">"B" -&gt; "rect"</span></p></td></tr></table></p><p>The first draw rule works normally and reads the image "player.png" from the current directory, but the second draw rule uses the built in shape "rect" to draw black boxes for all of the
well, boxes, in the game.</p><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Actions&quot;">4<tt>&nbsp;</tt><a name="(part._.Actions)"></a>Actions</h3><p>The Puzzler language supports basic keyboard input via the <span style="font-style: italic">action section</span>. <span style="font-weight: bold">Currently the only supported type of input is moving entities around the game grid.</span></p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Action_Rules&quot;">4.1<tt>&nbsp;</tt><a name="(part._.Action_.Rules)"></a>Action Rules</h4><p>The <span style="font-style: italic">action section</span> starts off similar to the draw section, with the only difference being how you define <span style="font-style: italic">action rule</span>s:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">action:</span></p></td></tr><tr><td><p><span class="stt">&lt;action_rule&gt;</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p><span style="font-style: italic">Action rule</span>s consist of 3 parts: an entity, the key that invokes the action, and a coordinate pair representing the change in position of the specified entity. This is easiest
to visualize with an example, so here&rsquo;s one from our <a href="#%28part._sokoban%29" data-pltdoc="x">Sokoban game</a>:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">action:</span></p></td></tr><tr><td><p><span class="stt">"P": "up" -&gt; (0, 1)</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p>We can break this rule down piece by piece, first noting that we are applying this action to the "P" entity (in our example this is the player). The next piece of information is the key to press
to trigger the action, which we specify with the word "up" (key names are the ones returned from <span class="RktSym">get-key-code</span> in racket/gui/base). The final part of our rule is a coordinate pair representing
the change in x and change in y (dx,dy) that we want our "P" entity to move by when we press "up". For this we have (0, 1), which means move 0 in the x-direction and positive 1 in the y-direction,
and in our case this works well because we want our "P" to move up by 1 grid square. The rest of the action section should make sense now, as the remaining rules are just variations on the
same formula:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">action:</span></p></td></tr><tr><td><p><span class="stt">"P": "up" -&gt; (0, 1)</span></p></td></tr><tr><td><p><span class="stt">"P": "down" -&gt; (0, -1)</span></p></td></tr><tr><td><p><span class="stt">"P": "left" -&gt; (-1, 0)</span></p></td></tr><tr><td><p><span class="stt">"P": "right" -&gt; (1, 0)</span></p></td></tr></table></p><p>All of the actions are defined for the "P" entity, and all we have to change is the key and coordinate pair to have movement in four directions.</p><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Interactions_and_Events&quot;">5<tt>&nbsp;</tt><a name="(part._.Interactions_and_.Events)"></a>Interactions and Events</h3><p>A game world without any interactivity would be very boring, and that&rsquo;s where Puzzler&rsquo;s <span style="font-style: italic">interaction section</span> comes in. The <span style="font-style: italic">interaction section</span> is where the interactions
between entities are defined. In Puzzler, an interaction is what happens when one entity tries to move into the space that is occupied by another entity.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Interaction_Rules&quot;">5.1<tt>&nbsp;</tt><a name="(part._.Interaction_.Rules)"></a>Interaction Rules</h4><p>Defining <span style="font-style: italic">interaction rule</span>s in Puzzler is similar to defining other types of rules, we start off with some symbol denoting the start of the <span style="font-style: italic">interaction section</span> and then list
each rule on its own line:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">interactions:</span></p></td></tr><tr><td><p><span class="stt">&lt;interaction_rule&gt;</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p>These <span style="font-style: italic">interaction rule</span>s consist of three parts: the acting entity (the one moving and thus triggering the interaction), the <span style="font-style: italic">interaction verb</span>, and the entity being acted upon. The
entities are represented by a single character, as usual, such as "P" or "B". The <span style="font-style: italic">interaction verb</span> can be one of three words: push, stop, or grab. These are the three types of interactions
in Puzzler and they are shown in the example below:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">interactions:</span></p></td></tr><tr><td><p><span class="stt">"P" push "B"</span></p></td></tr><tr><td><p><span class="stt">"B" stop "B"</span></p></td></tr><tr><td><p><span class="stt">"P" grab "T"</span></p></td></tr></table></p><p>The first rule in this example says that whenever a "P" entity moves into a space where a "B" is occupying, the "P" will push the "B" in whatever direction "P" is moving in. It is important to
note that <span style="font-weight: bold">entities cannot be pushed outside the bounds of the map</span>.</p><p>The second rule might seem a little confusing, but imagine for a second that in our game "B" means "box" and there are multiple boxes on the map. If our "P" can go pushing boxes around all day long,
we might want it so that if a "P" tries to push two boxes at a time (that is, push one box into a space occupied by another), the second box will stop the first. That is all this rule is stating: boxes
cannot push other boxes. Interestingly enough, we could change this rule to <span style="font-style: italic">"B" push "B"</span>, and our "P" entity would be able to push multiple boxes at a time.</p><p>The final rule, "grab", could just as accurately be called "replace". When "P" moves into the space occupied by "T", it will "grab" it and thus remove it from the game&rsquo;s map. This can be useful if you want
a game where your player has to navigate some puzzle and upon solving it they "grab" an entity to win the game.</p><h5 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Conflicting_Interactions&quot;">5.1.1<tt>&nbsp;</tt><a name="(part._.Conflicting_.Interactions)"></a>Conflicting Interactions</h5><p>After having seen a few interactions, you may thing "push is the opposite of stop, so what happens if I define them both?" While this is an interesting question, the answer is pretty boring: <span style="font-weight: bold">Puzzler takes
the first interaction and will ignore the rest</span>. For example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">interactions:</span></p></td></tr><tr><td><p><span class="stt">"P" push "B"</span></p></td></tr><tr><td><p><span class="stt">"P" stop "B"</span></p></td></tr></table></p><p>In this particular <span style="font-style: italic">interaction section</span>, the second rule will never actually be triggered because when a "P" moves into a space with a "B", Puzzler will see that there is a "push" interaction defined
and it will trigger that.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Events__Well__just_Event_Really_&quot;">5.2<tt>&nbsp;</tt><a name="(part._.Events__.Well__just_.Event_.Really_)"></a>Events (Well, just Event Really)</h4><p>Puzzler has a somewhat obscure and situational feature called the <span style="font-style: italic">event section</span>. This is defined much the same as all of the other sections, and it only has one supported "type" at the moment.
It is best to explain events with an example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">events:</span></p></td></tr><tr><td><p><span class="stt">"P" onexit "B"</span></p></td></tr></table></p><p>This event, called <span style="font-style: italic">onexit</span>, looks a lot like an <span style="font-style: italic">interaction</span>. The difference is that this event triggers every time the first entity moves (thus the name, "onexit"). When the "P" entity
exits a space on the map, that space will be filled with the second entity ("B"). <span style="font-style: italic">onexit</span> is definitely situational, and I would encourage you to check out
<a href="https://github.com/aowens-21/puzzler/blob/master/examples/trail-example.rkt"><span style="font-style: italic">trail-example.rkt</span></a> on the Puzzler GitHub for a better idea of how it might be used.</p><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Winning_and_Losing&quot;">6<tt>&nbsp;</tt><a name="(part._.Winning_and_.Losing)"></a>Winning and Losing</h3><p>All games in Puzzler need some way to represent winning and losing, and these conditions are defined in the <span style="font-style: italic">win section</span> and <span style="font-style: italic">lose section</span>, respectively. In this section, we&rsquo;ll talk
about the different kinds of win/lose conditions supported by the Puzzler language.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Defining_Win_Conditions&quot;">6.1<tt>&nbsp;</tt><a name="(part._.Defining_.Win_.Conditions)"></a>Defining Win Conditions</h4><p>The <span style="font-style: italic">win section</span> follows the pattern of all the other Puzzler sections:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">win:</span></p></td></tr><tr><td><p><span class="stt">&lt;win_rule&gt;</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p>Puzzler supports two types of win rules: <span style="font-style: italic">count_items</span> and <span style="font-style: italic">straight_path_to</span>. The <span style="font-style: italic">count_items</span> takes a type of entity and a number and it is triggered when the number of
that particular entities on the map is equal to the supplied number. <span style="font-style: italic">straight_path_to</span> takes two entities and is triggered when there is either a horizontal or vertical clear path
(unblocked by another entity) between the two entity types. For example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">win:</span></p></td></tr><tr><td><p><span class="stt">"T" count_items 0</span></p></td></tr><tr><td><p><span class="stt">"P" straight_path_to "E"</span></p></td></tr></table></p><p>The first rule in this example counts the number of "T" entities on the map and changes the win state of the game to true if the count is zero. The second rule will trigger the win state if there is
any clear horizontal or vertical path between any "P" and "E" entities.</p><h5 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Goal_Maps&quot;">6.1.1<tt>&nbsp;</tt><a name="(part._.Goal_.Maps)"></a>Goal Maps</h5><p>There is another type of win condition in Puzzler, called a <span style="font-style: italic">goal map</span>, which is defined in a different section from the other <span style="font-style: italic">win rule</span>s. Goal maps are defined similarly to
<a href="#%28part._maps%29" data-pltdoc="x">regular maps</a>. Consider the following example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">START_GOAL_MAP</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">P#####</span></p></td></tr><tr><td><p><span class="stt">######</span></p></td></tr><tr><td><p><span class="stt">END_GOAL_MAP</span></p></td></tr></table></p><p>If a goal map is defined in Puzzler, the game will compare the current map to the goal map every time the game state updates. If the current map ever matches the goal map, the game win state will be
set to true. In this example, we have essentially defined a new win condition stating that the "P" entity must be in the 2nd row and 1st column of the game&rsquo;s map. It is important to know that since
Puzzler supports multiple maps, <span style="font-weight: bold">the number of goal maps must equal the number of maps</span>.</p><h4 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Defining_Lose_Conditions&quot;">6.2<tt>&nbsp;</tt><a name="(part._.Defining_.Lose_.Conditions)"></a>Defining Lose Conditions</h4><p>Lose conditions are extremely similar to win conditions, except that they are defined in a <span style="font-style: italic">lose section</span>. The lose section looks like this:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">lose:</span></p></td></tr><tr><td><p><span class="stt">&lt;lose_rule&gt;</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p><span style="font-style: italic">lose_rule</span>s support the same types as <span style="font-style: italic">win_rule</span>s, which were described earlier. There is, however, currently <span style="font-weight: bold">no way to use a goal map to trigger a lose state in a Puzzler game</span>.</p><h3 x-source-module="(lib &quot;puzzler/scribblings/puzzler.scrbl&quot;)" x-source-pkg="puzzler" x-part-tag="&quot;Conclusion_and_Future_Work&quot;">7<tt>&nbsp;</tt><a name="(part._.Conclusion_and_.Future_.Work)"></a>Conclusion and Future Work</h3><p>Hopefully by now you&rsquo;ve seen what Puzzler is capable of. I would encourage you to go check out the examples on the Puzzler github page to see how these different pieces can be put together
to build interesting games. I would also encourage you to take a look at Steven Lavelle&rsquo;s <a href="https://www.puzzlescript.net/">PuzzleScript</a> language, which inspired the design of Puzzler
significantly. It is a good tool for web-based puzzle games rather than the desktop ones you can create with Puzzler.</p><p>While it&rsquo;s true that Puzzler is already expressive enough to represent a variety of puzzle games, there is plenty of future work to improve both its expressiveness and robustness. The Puzzler system is
very limited in its number of interactions and win/lose conditions, and a larger set would increase the expressiveness of the language. Another interesting project would be to implement a custom interaction
system which would allow the user to define things like <span style="font-style: italic">push</span> and <span style="font-style: italic">stop</span> themselves.</p><p>If you are interested in using Puzzler for something it can&rsquo;t currently express, feel free to submit a pull request, issue, or even fork the project and develop against it yourself. I am not "actively"
working on new features for Puzzler, but I would be happy to engage with anyone interested in Puzzler or game development with Racket in general!</p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.6&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index-2.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.6&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body>
<!-- Mirrored from docs.racket-lang.org/puzzler/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 07 Sep 2022 03:04:47 GMT -->
</html>